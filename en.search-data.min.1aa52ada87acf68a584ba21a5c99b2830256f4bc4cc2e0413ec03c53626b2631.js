'use strict';(function(){const b={cache:!0};b.doc={id:'id',field:['title','content'],store:['title','href','section']};const a=FlexSearch.create('balance',b);window.bookSearchIndex=a,a.add({id:0,href:'/azure/give-access/',title:"Accesos a BD",section:"AZURE",content:"1. perfilamiento de accesos a en base de datos (Authorization) #  1.1 Acceso para un grupo de AAD #  GRANTALTERONSCHEMA::[web]TO[g_magnet];GRANTSELECTONSCHEMA::[web]TO[g_magnet];GRANTCONTROLONSCHEMA::[web]TO[g_magnet];GRANTCREATEPROCEDUREto[g_magnet];1.2 Acceso para un usuario de AAD #  GRANTALTERONSCHEMA::[web]TO[usuario1@uc.cl];GRANTSELECTONSCHEMA::[web]TO[usuario1@uc.cl];GRANTCONTROLONSCHEMA::[web]TO[usuario1@uc.cl];GRANTCREATEPROCEDUREto[usuario1@uc.cl];GRANTCREATEVIEWTO[usuario1@uc.cl];1.3 Acceso para un usuario con autenticación SQL-login #  1.4 Para comprobar accesos #  EXECUTEASUSER=\u0026#39;usuario1@uc.cl\u0026#39;"}),a.add({id:1,href:'/azure/apisipa/',title:"API SIPA",section:"AZURE",content:"HOW-TO #  La API se llama a través de un HTTP trigger desplegado en la siguiente ruta:\nhttps://apidwuc.azurewebsites.net/\nY cuyos endpoints para las consultas de acádemicos y unidades académicas son los siguientes:\n   Objeto de consulta Endpoint Descripción     Unidades académicas /uas Devuelve el total de las unidades académicas de la universidad.   Unidad académica /ua/\u0026lt;id unidad académica\u0026gt; Devuelve una unidad académica en según el ID de esta, donde \u0026lt;id unidad académica\u0026gt; es el número (ID) de la unidad académica. El link redirecciona a la unidad académica con \u0026lt;id unidad académica\u0026gt; = 1 para ilustrar.   Académicos /academicos Devuelve la totalidad de los académicos.   Académicos por código de persona /academicos_codper/\u0026lt;cod_per\u0026gt; Devuelve un académico según su código de persona. El link redirecciona al académico con \u0026lt;cod_per\u0026gt; = 163754 para ilustrar.   Académicos por usuario UC /academicos_usuario/\u0026lt;usuario_uc\u0026gt; Devuelve un académico según su usuario UC. El link redirecciona al académico con \u0026lt;usuario_uc\u0026gt; = xdarriet para ilustrar.    "}),a.add({id:2,href:'/sql/Modelo-DAC/Configuraci%C3%B3n-DAC/',title:"Configuración DAC",section:"DAC",content:"Discretionary access control (DAC)\nPara poder revisar las politicas ya aplicadas dirigirse a la sección de monitoring XX:\nPor otro lado para configurar un nuevo permiso o acceso se debe realizar lo siguiente:\n1. Realizar inserciones tablas DM, GD, DC #  listado de tablas y scripts de ejemplo de inserciones.\n2. Ejecutar pipeline de modelo DAC (para aplicar politicas) #  foto del adf\n3. Verificar que se han aplicado accesos #  Execute as user etc\u0026hellip;\n"}),a.add({id:3,href:'/azure/create-user/',title:"Creación usuarios",section:"AZURE",content:"Cómo crear usuarios y roles en Bases de Datos con AAD auth #  Estructura estándar #   Cómo ver qué usuarios tienen accesos. A qué objeto tiene acceso un usuario. Cómo añadir un usuario nuevo a un grupo en AAD existente.  Cómo añadir al grupo AAD en SQL.    1. Crear usuario #  1.1 Autenticación: SQL login #  CREATELOGINMaryUserWITHPASSWORD=\u0026#39;8YpFWHhrWUgTTbED\u0026#39;;CREATEUSERMaryUserFROMLOGINMaryUser;-- son 2 veces, uno en la master y otro en tu BD ALTERROLEdb_datareaderADDMEMBERMaryUser;-- en tu BD ALTERROLEdb_ddladminADDMEMBERMaryUser;ALTERROLEdb_datawriterADDMEMBERMaryUser;1.2 Autenticación: AAD #  CREATEUSER[g_magnet]FROMEXTERNALPROVIDER;1.2 Verificación de usuarios #  SELECTnameASusername,create_date,modify_date,type_descastype,authentication_type_descASauthentication_typeFROMsys.database_principalsORDERBYtype_desc;"}),a.add({id:4,href:'/sql/Modelo-DAC/',title:"DAC",section:"SQL",content:""}),a.add({id:5,href:'/sistemas/admision/indicadores/',title:"Indicadores",section:"Admision",content:"Sesión de Convergencia: Indicadores Admisión #  A continuación un análisis con los cruces para responder a los indicadores para ADMISIÓN.\n   ID Indicador Definición     1 Admisión especial, según vía de Equidad. Número de postulantes de carreras de pregrado, según vía de equidad, en un año-periodo de admisión.   1 Admisión especial, según vía de Equidad. Número de postulantes-seleccionados a carreras de pregrado, según vía de equidad en un año-periodo de admisión.   1 Admisión especial, según vía de Equidad. Número de estudiantes matriculados en carreras de pregrado , según vía de equidad en un año-periodo de admisión.   2 Estudiantes-postulantes pertenecientes a una etnia. Número de estudiantes pertenecientes a una etnia, por año-periodo de admisión.   3 Postulantes con puntaje nacional, por año-periodo de admisión. Número de estudiantes con puntaje nacional, por año-periodo de admisión.   4 Estudiantes de cursos superiores que postulan a la UC. Número de estudiantes que no vienen directo de un establecimiento de educación secundaria (año de egreso).   5 Estudiantes-Postulantes según nacionalidad por año-periodo de admisión. Número de estudiantres-postulantes según nacionalidad por año-periodo de admisión.   6 Estudiantes-Postulantes, según IVE del establecimiento de origen, por año-periodo de admisión. Número de estudiantes- Postulantes, según IVE del establecimiento de origen, por año-periodo de admisión.   7 Estudiantes, según carreras de preferencia postulada, por año-periodo de admisión. Número de estudiantes seleccionados, según carreras de preferencia postulada por año-periodo de admisión.   7 Estudiantes, según carreras de preferencia postulada, por año-periodo de admisión. Número de estudiantes matriculados, según carreras de preferencia postulada por año-periodo de admisión.   8 Admisión en programas de magister y doctorado. Número de estudiantes: postulantes, aceptados y rechazados en programas de magíster y doctorado por año-periodo de admisión.   8 Admisión en programas de magister y doctorado. Número de matriculados en programas de magíster y doctorado por año-periodo de admisión.    1. Admisión especial, según vía de Equidad #  Número de postulantes de carreras de pregrado, según vía de equidad, en un año-periodo de admisión. #  SELECT ANO_ADMIS , COUNT(1) FROM ADMISION.TBL_VW_FT_ADMISION_ESP_ORD WHERE COD_CASO_ADMIS IN (218, 259, 221, 237, 209, 226) GROUP BY ANO_ADMIS ORDER BY ANO_ADMIS Número de postulantes seleccionados a carreras de pregrado según vía de equidad en un año-periodo de admisión #  SELECT ANO_ADMIS , COUNT(1) FROM ADMISION.TBL_VW_FT_ADMISION_ESP_ORD WHERE COD_CASO_ADMIS IN (218, 259, 221, 237, 209, 226) AND COD_ESTADO_POSTULACION IN (4, 6) OR COD_SIT_POSTULACION = \u0026#39;S\u0026#39; GROUP BY ANO_ADMIS ORDER BY ANO_ADMIS Número de estudiantes matriculados en carreras de pregrado según vía de equidad en un año-periodo de admisión #  SELECT ANO_ADMIS , COUNT(1) FROM ADMISION.TBL_VW_FT_ADMISION_ESP_ORD WHERE COD_CASO_ADMIS IN (218, 259, 221, 237, 209, 226) AND COD_ESTADO_POSTULACION = 7 OR COD_SIT_POSTULACION = \u0026#39;U\u0026#39; GROUP BY ANO_ADMIS ORDER BY ANO_ADMIS 2. Estudiantes-postulantes pertenecientes a una etnia #  Número de estudiantes pertenecientes a una etnia, por año-periodo de admisión #  ---- Se debe traer las tablas etnia y postul a sandbox SELECT ANO_ADMIS , COUNT(1) FROM ADMISION.POSTUL WHERE COD_ETNIA \u0026lt;\u0026gt; 10 AND COD_ETNIA IS NOT NULL GROUP BY ANO_ADMIS 3. Postulantes con puntaje nacional por año-periodo de admisión #  Número de estudiantes con puntaje nacional por año-periodo de admisión #  SELECT ANO_ADMIS , COUNT(1) FROM ADMISION.TBL_VW_FT_ADMISION_ESP_ORD WHERE CIE = 850 OR HYC = 850 OR LYC = 850 OR MAT = 850 GROUP BY ANO_ADMIS ORDER BY ANO_ADMIS 4. Estudiantes de cursos superiores que postulan a la UC #  Número de estudiantes que no vienen directo de un establecimiento de educación secundaria (año de egreso) #  5. Estudiantes-Postulantes según nacionalidad por año-periodo de admisión #  Número de estudiantres-postulantes según nacionalidad por año-periodo de admisión #  -- Desagregado por país SELECT COUNT(1) NUM_POSTUL , PA.NOM_PAIS , PE.ANO_ADMIS FROM ADMISION.PERSONA_ADMISION AS PA INNER JOIN ADMISION.POSTULACION_EFECT AS PE ON (PA.RUT = PE.RUT) GROUP BY PA.NOM_PAIS , PE.ANO_ADMIS ORDER BY PE.ANO_ADMIS -- Desagregado por nacionalidad (chilena, extranjera) SELECT COUNT(1) NUM_POSTUL , PA.NACIONALIDAD , PE.ANO_ADMIS FROM ADMISION.PERSONA_ADMISION AS PA INNER JOIN ADMISION.POSTULACION_EFECT AS PE ON (PA.RUT = PE.RUT) GROUP BY PA.NACIONALIDAD , PE.ANO_ADMIS ORDER BY PE.ANO_ADMIS 6. Estudiantes-Postulantes según IVE del establecimiento de origen, por año-periodo de admisión #  Número de estudiantes-postulantes según IVE del establecimiento de origen, por año-periodo de admisión #  -- Traer trabla INDICE_VULNER_ESCOLAR a la BD Sandbox_Prod  SELECT COUNT(1) AS NUM_POSTUL , ADM.COD_COLEGIO , ADM.ANO_COLEGIO , ADM.NOM_COLEGIO FROM ADMISION.INDICE_VULNER_ESCOLAR AS IVE INNER JOIN ADMISION.COLEGIO_ADMISION AS ADM ON IVE.ROL_BASE_DATO = ADM.ROL_BASE_DATO GROUP BY ADM.COD_COLEGIO , ADM.NOM_COLEGIO , ADM.ANO_COLEGIO ORDER BY ADM.ANO_COLEGIO DESC 7. Estudiantes según carreras de preferencia postulada, por año-periodo de admisión #  Número de estudiantes seleccionados según carreras de preferencia postulada por año-periodo de admisión #  SELECT COUNT(1) NUM_POSTUL , HC.NOM_CARRERA , PE.ANO_ADMIS FROM ADMISION.POSTULACION_EFECT AS PE INNER JOIN ADMISION.HIST_CARRERA AS HC ON (PE.CLAVE_NACIONAL = HC.CLAVE_NACIONAL) WHERE PE.PREF = 1 AND PE.ANO_ADMIS \u0026gt; 2008 AND (PE.COD_SIT_POSTULACION_INICIAL = \u0026#39;S\u0026#39; OR PE.COD_SIT_POSTULACION_ANT = \u0026#39;S\u0026#39; OR PE.COD_SIT_POSTULACION = \u0026#39;S\u0026#39;) GROUP BY HC.NOM_CARRERA , PE.ANO_ADMIS Número de estudiantes matriculados según carreras de preferencia postulada por año-periodo de admisión #  SELECT COUNT(1) NUM_POSTUL , HC.NOM_CARRERA , PE.ANO_ADMIS FROM ADMISION.POSTULACION_EFECT AS PE INNER JOIN ADMISION.HIST_CARRERA AS HC ON (PE.CLAVE_NACIONAL = HC.CLAVE_NACIONAL) WHERE PE.PREF = 1 AND PE.ANO_ADMIS \u0026gt; 2008 AND (PE.COD_SIT_POSTULACION = \u0026#39;U\u0026#39; OR PE.COD_SIT_POSTULACION_ANT =\u0026#39;U\u0026#39; OR PE.COD_SIT_POSTULACION_INICIAL =\u0026#39;U\u0026#39;) GROUP BY HC.NOM_CARRERA , PE.ANO_ADMIS 8. Admisión en programas de magister y doctorado #  Revisar si los COD_ESTADO_POSTULACION están correctos.\nNúmero de estudiantes: postulantes, aceptados y rechazados en programas de magíster y doctorado por año-periodo de admisión #  SELECT COUNT(1) , ANO_ADMIS FROM ADMISION.TBL_VW_FT_ADMISION_ESP_ORD WHERE COD_CASO_ADMIS IN (110, 150, 190, 111, 125, 112) AND COD_ESTADO_POSTULACION \u0026lt;\u0026gt; 7 GROUP BY ANO_ADMIS ORDER BY ANO_ADMIS Número de matriculados en programas de magíster y doctorado por año-periodo de admisión #  SELECT COUNT(1) , ANO_ADMIS FROM ADMISION.TBL_VW_FT_ADMISION_ESP_ORD WHERE COD_CASO_ADMIS IN (110, 150, 190, 111, 125, 112) AND COD_ESTADO_POSTULACION IN (6, 7, 8) GROUP BY ANO_ADMIS ORDER BY ANO_ADMIS DISCLAIMER\nPara responder a los indicadores en 2, 4, 5, 6 y 7 se generó la vista:\nSandobox-Datagov_Prod.ADMISION.TBL_VW_FT_ADMISION_PAS   "}),a.add({id:6,href:'/etl/mallas/malla-adl/',title:"Malla ADL",section:"Mallas",content:"Definición general #  El proceso de datalake consiste en traer distintos documentos, tablas y archivos y depositarlos en un contenedor del datalake. En particular se depositan en el contenedor raw en la siguiente ruta:\nraw/nombre_origen/nombre_sistema/nombre_owner/nombre_tabla/año/mes/dia/nombre_tabla_año_mes_dia.csv Proceso de carga a datalake #  1. Verificar y cargar en MCP.MCP_CATALOGO #  Si la tabla exista, se debe verificar que la columna FLG_ADL mantenga el valor 1.\nSi la tabla no existe, se debe realizar una inserción a la tabla de catálogo de la siguiente forma:\nForma general\nINSERT INTO MCP.MCP_CATALOGO (ORIGEN_SISTEMA,NOMBRE_SISTEMA,NOMBRE_OWNER,NOMBRE_TABLA,DESC_TABLA) VALUES(\u0026#39;ORIGEN_1\u0026#39;,\u0026#39;SISTEMA_1\u0026#39;,\u0026#39;ESQUEMA_1\u0026#39;,\u0026#39;TABLA_1\u0026#39;,\u0026#39;Descripción de la tabla 1\u0026#39;); Ejemplo\nINSERT INTO MCP.MCP_CATALOGO (ORIGEN_SISTEMA,NOMBRE_SISTEMA,NOMBRE_OWNER,NOMBRE_TABLA,DESC_TABLA) VALUES(\u0026#39;ORACLE\u0026#39;,\u0026#39;UCLIBE\u0026#39;,\u0026#39;ADMISION\u0026#39;,\u0026#39;INSTITUCION_RESP\u0026#39;,\u0026#39;tabla que registra las instituciones...\u0026#39;); 2. Verificar/actualizar FLG #  Como se mencionó anteriormente en caso de que exista la tabla en el catalogo solo se debe actualizar flag.\nUpdate MCP.MCP_CATALOGO SET FLG_ADL = 1 WHERE NOMBRE_TABLA = \u0026#39;TABLA_1\u0026#39; AND NOMBRE_OWNER = \u0026#39;ESQUEMA_1\u0026#39; 3. Verificar en ETL si existe el origen-sistema-owner creado #  Para esto se debe checkear el datafactory dependiendo del ambiente en el que se requiere realizar la carga, adf-dev o adf-prod.\nUna vez dentro del datalake, se debe dirigir al pipeline:\nFASE 2 \u0026gt; Malla General \u0026gt; Malla ADL Dentro de este pipeline se debe chequear que exista el ORIGEN para el cual se va a realizar la carga.\n3.1 En caso de existir en origen se debe checkear un nivel anidado si existe el SISTEMA en el ETL #  Dentro del pipeline anterior se debe dirigir a:\nFASE 2 \u0026gt; Malla General \u0026gt; Malla ADL \u0026gt; ORIGEN Una vez dentro, se debe verificar si existe el sistema (pipeline con el nombre del sistema a cargar)\n3.1.1 En caso de existir el sistema #  Si existe el sistema queda por checkear solo si existe el owner para ese sistema\n3.1.2 En caso de no existir el sistema #  Se debe crear el pipeline correspondiente con el parametro del nuevo sistema.\n"}),a.add({id:7,href:'/sistemas/banner/metadata/',title:"Metadata",section:"Banner",content:"Queries para obtener la data relativa de Banner Normalizado #  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217  EXECUTE AS USER = \u0026#39;psotou@uc.cl\u0026#39;; WITH all_tables_saturn AS( SELECT name ,object_id ,principal_id ,schema_id ,SCHEMA_NAME(schema_id) as schema_name ,type ,type_desc ,create_date ,modify_date ,is_ms_shipped ,is_published ,is_schema_published FROM sys.objects where SCHEMA_NAME(schema_id) = \u0026#39;SATURN\u0026#39; AND type IN (\u0026#39;U\u0026#39;) ) , all_tables_general AS ( --27 filas general  SELECT name ,object_id ,principal_id ,schema_id ,SCHEMA_NAME(schema_id) as schema_name ,type ,type_desc ,create_date ,modify_date ,is_ms_shipped ,is_published ,is_schema_published FROM sys.objects where SCHEMA_NAME(schema_id) = \u0026#39;GENERAL\u0026#39; AND type IN (\u0026#39;U\u0026#39;) ) , all_object_banner AS ( --280 objetos (triggers, SP\u0026#39;s, tables,primary_keys y constrains--- SELECT name ,object_id ,principal_id ,schema_id ,SCHEMA_NAME(schema_id) as schema_name ,type ,type_desc ,create_date ,modify_date ,is_ms_shipped ,is_published ,is_schema_published FROM sys.objects where SCHEMA_NAME(schema_id) = \u0026#39;NORMALIZADO_BANNER\u0026#39; ) , all_tables_banner AS ( --46 tablas banner  SELECT name ,object_id ,principal_id ,schema_id ,SCHEMA_NAME(schema_id) as schema_name ,type ,type_desc ,create_date ,modify_date ,is_ms_shipped ,is_published ,is_schema_published FROM sys.objects where SCHEMA_NAME(schema_id) = \u0026#39;NORMALIZADO_BANNER\u0026#39; AND type IN (\u0026#39;U\u0026#39;) --select * FROM sys.objects where SCHEMA_NAME(schema_id) = \u0026#39;NORMALIZADO_BANNER\u0026#39; AND type IN (\u0026#39;P\u0026#39;,\u0026#39;X\u0026#39;,\u0026#39;RF\u0026#39;,\u0026#39;PC\u0026#39;)  ) , all_procedures_banner AS ( --95 sp\u0026#39;s-- SELECT * FROM sys.procedures WHERE SCHEMA_NAME(schema_id) = \u0026#39;NORMALIZADO_BANNER\u0026#39; ) , all_dependencies_sp AS ( --358 referencias--  SELECT --- ENTIDAD REFERENCIADORA 	OBJECT_SCHEMA_NAME ( referencing_id ) AS referencing_schema_name, OBJECT_NAME(referencing_id) AS referencing_entity_name, o.type AS referencing_type, o.type_desc AS referencing_desciption, COALESCE(COL_NAME(referencing_id, referencing_minor_id), \u0026#39;(n/a)\u0026#39;) AS referencing_minor_id, referencing_class_desc, ---ENTIDAD REFERENCIADA 	referenced_class_desc, referenced_server_name, referenced_database_name, referenced_schema_name, referenced_entity_name, o2.type AS referenced_type, o2.type_desc AS referenced_desciption, COALESCE(COL_NAME(referenced_id, referenced_minor_id), \u0026#39;(n/a)\u0026#39;) AS referenced_column_name, is_caller_dependent, is_ambiguous FROM sys.sql_expression_dependencies AS sed INNER JOIN sys.objects AS o ON sed.referencing_id = o.object_id LEFT JOIN sys.objects AS o2 ON sed.referenced_id = o2.object_id WHERE OBJECT_SCHEMA_NAME ( referencing_id ) = \u0026#39;NORMALIZADO_BANNER\u0026#39; and o.type IN (\u0026#39;P\u0026#39;,\u0026#39;X\u0026#39;,\u0026#39;RF\u0026#39;,\u0026#39;PC\u0026#39;) --and OBJECT_NAME(referencing_id) = \u0026#39;UPDATE_ACADEMIC_PROGRAM\u0026#39; --and OBJECT_NAME(referenced_id) = \u0026#39;__academic_situation\u0026#39;  ) /*** QUERY PARA OBTENER TABLAS DE INPUT DEL MODELO SELECT DISTINCT referenced_schema_name,referenced_entity_name FROM all_dependencies_sp where referenced_schema_name NOT IN (\u0026#39;NORMALIZADO_BANNER\u0026#39;,\u0026#39;MCP\u0026#39;) ***/ /*** QUERY PARA OBTENER TABLAS DE OUTPUT DEL MODELO SELECT DISTINCT referenced_schema_name,referenced_entity_name FROM all_dependencies_sp where referenced_schema_name IN (\u0026#39;NORMALIZADO_BANNER\u0026#39;) ***/ ------------------------------------------------------------------------------------------- --SELECT * FROM all_tables_saturn --SELECT * FROM all_tables_general --SELECT * FROM all_object_banner --order by TYPE  --IMPORTANTE NO USAR sys.sql_dependencies ---This feature will be removed in a future version of Microsoft SQL Server. Avoid using this feature in new development work, and plan to modify applications that currently use this feature. Use sys.sql_expression_dependencies instead.  -- ESTA FUNCION NO ESTA EN DW SYNAPSE --SELECT * FROM sys.dm_sql_referenced_entities  --select * FROM sys.sql_expression_dependencies  --GLOSARIO --referencing_id =\u0026gt; entidad que referencia --referenced_id =\u0026gt; entidad referenciada  -------------------------------ENTIDADES QUE SON REFERENCIADAS---------------------------  --SELECT OBJECT_NAME(referencing_id) AS referencing_entity_name, --	o.type AS referencing_type, -- o.type_desc AS referencing_desciption, -- COALESCE(COL_NAME(referencing_id, referencing_minor_id), \u0026#39;(n/a)\u0026#39;) AS referencing_minor_id, -- referencing_class_desc, -- referenced_server_name, referenced_database_name, referenced_schema_name, -- referenced_entity_name, -- COALESCE(COL_NAME(referenced_id, referenced_minor_id), \u0026#39;(n/a)\u0026#39;) AS referenced_column_name, -- is_caller_dependent, is_ambiguous --FROM sys.sql_expression_dependencies AS sed --INNER JOIN sys.objects AS o ON sed.referencing_id = o.object_id --WHERE OBJECT_SCHEMA_NAME ( referencing_id ) = \u0026#39;NORMALIZADO_BANNER\u0026#39; and o.type IN (\u0026#39;P\u0026#39;,\u0026#39;X\u0026#39;,\u0026#39;RF\u0026#39;,\u0026#39;PC\u0026#39;) --GO  -------------------------------ENTIDADES QUE REFERENCIAN---------------------------  --SELECT OBJECT_SCHEMA_NAME ( referencing_id ) AS referencing_schema_name, -- OBJECT_NAME(referencing_id) AS referencing_entity_name, --	o.type AS referencing_type, -- o.type_desc AS referencing_desciption, -- COALESCE(COL_NAME(referencing_id, referencing_minor_id), \u0026#39;(n/a)\u0026#39;) AS referencing_minor_id, -- referencing_class_desc, referenced_class_desc, -- referenced_server_name, referenced_database_name, referenced_schema_name, -- referenced_entity_name, -- COALESCE(COL_NAME(referenced_id, referenced_minor_id), \u0026#39;(n/a)\u0026#39;) AS referenced_column_name, -- is_caller_dependent, is_ambiguous --FROM sys.sql_expression_dependencies AS sed --INNER JOIN sys.objects AS o ON sed.referencing_id = o.object_id --WHERE OBJECT_SCHEMA_NAME ( referencing_id ) = \u0026#39;NORMALIZADO_BANNER\u0026#39; and o.type IN (\u0026#39;P\u0026#39;,\u0026#39;X\u0026#39;,\u0026#39;RF\u0026#39;,\u0026#39;PC\u0026#39;) AND OBJECT_NAME(referencing_id) = \u0026#39;UPDATE_SCHOOL_FINANCING_TYPE\u0026#39; --GO  -------------------------------TAMBIEN SE PUEDEN VER VISTAS-TABLAS-------------------------------  --SELECT OBJECT_SCHEMA_NAME ( referencing_id ) AS referencing_schema_name, -- OBJECT_NAME(referencing_id) AS referencing_entity_name, --	o.type AS referencing_type, -- o.type_desc AS referencing_desciption, -- COALESCE(COL_NAME(referencing_id, referencing_minor_id), \u0026#39;(n/a)\u0026#39;) AS referencing_minor_id, -- referencing_class_desc, referenced_class_desc, -- referenced_server_name, referenced_database_name, referenced_schema_name, -- referenced_entity_name, -- COALESCE(COL_NAME(referenced_id, referenced_minor_id), \u0026#39;(n/a)\u0026#39;) AS referenced_column_name, -- is_caller_dependent, is_ambiguous --FROM sys.sql_expression_dependencies AS sed --INNER JOIN sys.objects AS o ON sed.referencing_id = o.object_id --WHERE o.type IN (\u0026#39;V\u0026#39;,\u0026#39;U\u0026#39;)  --SELECT * FROM MCP.CATALOGO_DSP  --, rel_tabla_sp AS ( --SELECT A.*,B.NOMBRE_TABLA,C.NOMBRE_PROCESO --FROM MCP.MCP_DSP_REL_TABLA_SP A --LEFT JOIN MCP.MCP_CATALOGO B ON A.ID_CATALOGO = B.ID_CATALOGO --LEFT JOIN MCP.MCP_DSP_CATALOGO C ON A.ID_CATALOGO_SP = C.ID_CATALOGO_SP --)  --, rel_sp_sp AS ( --SELECT A.*,B.NOMBRE_PROCESO AS NOMBRE_PROCESO_HIJO,C.NOMBRE_PROCESO AS NOMBRE_PROCESO_PADRE --FROM MCP.MCP_DSP_REL_SP_SP A --LEFT JOIN MCP.MCP_DSP_CATALOGO B ON A.ID_CATALOGO_SP_HIJO = B.ID_CATALOGO_SP --LEFT JOIN MCP.MCP_DSP_CATALOGO C ON A.ID_CATALOGO_SP_PADRE = C.ID_CATALOGO_SP --)  --SELECT * --FROM rel_sp_sp A  --SELECT referencing_schema_name,referencing_entity_name,referenced_schema_name,referenced_entity_name --FROM all_dependencies_sp --where referenced_type IN (\u0026#39;U\u0026#39;) AND referenced_schema_name \u0026lt;\u0026gt; \u0026#39;MCP\u0026#39; AND referenced_schema_name IN (\u0026#39;SATURN\u0026#39;,\u0026#39;GENERAL\u0026#39;) order BY referenced_schema_name    "}),a.add({id:8,href:'/etl/monitoreo/links-pbi/',title:"Monitoreo: Reportes Power BI",section:"Monitoreo",content:"Definición general #  Esta seccion blabla\nReportes monitoreo #  1. Monitoreo Catalogo y consistencia de tablas #  2. Monitoreo Proceso ETL #  3. Monitoreo Proceso DAC #  4. Internado de aceleración #  "}),a.add({id:9,href:'/sql/Modelo-DAC/Script_Ejemplo_uso/',title:"Script ejemplo de uso DAC",section:"DAC",content:"Discretionary access control (DAC)\n1. Crear politicas #  UPDATE DAC_SECURITY.DAC_USER_ENTITY_ACCESS SET flag_entity_access = 0 -- negar acceso a tabla UPDATE DAC_SECURITY.DAC_USER_ROW_LEVEL_SECURITY SET flag_rls_vigencia = 1 UPDATE DAC_SECURITY.DAC_USER_UNMASK SET flag_unmask = 1 UPDATE DAC_SECURITY.DAC_DATA_MASKING SET flag_dm_vigencia = 1 UPDATE DAC_SECURITY.DAC_DATA_CLASSIFICATION SET flag_dc_vigencia = 1/ 1. Borrar politicas #  UPDATE DAC_SECURITY.DAC_USER_ENTITY_ACCESS SET flag_entity_access = 1 -- dar acceso a tabla UPDATE DAC_SECURITY.DAC_USER_ROW_LEVEL_SECURITY SET flag_rls_vigencia = 0 UPDATE DAC_SECURITY.DAC_USER_UNMASK SET flag_unmask = 0 UPDATE DAC_SECURITY.DAC_DATA_MASKING SET flag_dm_vigencia = 0 UPDATE DAC_SECURITY.DAC_DATA_CLASSIFICATION SET flag_dc_vigencia = 0/ 3. Validar existencia de políticas #  SELECT * FROM sys.security_policies -- RLS SELECT * FROM sys.masked_columns -- Data Masking SELECT * FROM sys.sensitivity_classifications -- Data Classification SELECT * FROM DAC_SECURITY.DAC_USER_CHECK_SELECT_PERMISSIONS -- SELECT permissions "}),a.add({id:10,href:'/sql/procedures/',title:"SP",section:"SQL",content:"  "}),a.add({id:11,href:'/etl/mallas/malla-stg/',title:"Malla STG",section:"Mallas",content:"Asumiendo que se realizó anteriormente el proceso de malla ADL, la tabla a actualizar ya se encuentra cargada en el MCP.MCP_CATALOGO, Con esto se deben realizar dos cosas:\n### 1. Verificar/actualizar FlG Como se mencionó anteriormente en caso de que exista la tabla en el catalogo solo se debe actualizar flag.\nUpdate [MCP].[MCP_CATALOGO] SET FLG_STG = 1 WHERE NOMBRE_TABLA = \u0026#39;TABLA_1\u0026#39; and NOMBRE_OWNER = \u0026#39;ESQUEMA_1\u0026#39; ### 2. Actualizar fecha de proceso\n"}),a.add({id:12,href:'/etl/mallas/malla-sp/',title:"Malla SP",section:"Mallas",content:"Proceso ETL para la transformación de tablas #  La malla SP corresponde a un conjunto de ejecuciones de los procedimientos almacenados que suceden en la base de datos STAGE. Este proceso es parte del flujo completo del ETL en el pipeline de \u0026ldquo;malla general\u0026rdquo; el cual es ejecutado diariamente.\nLa malla SP en el contexto del pipeline:\n"}),a.add({id:13,href:'/etl/mallas/malla-sbx/',title:"Malla SBX",section:"Mallas",content:"asdasd\n"}),a.add({id:14,href:'/etl/mallas/malla-mdm/',title:"Malla MDM",section:"Mallas",content:"Malla MDM #  La Malla MDM se encarga de consolidar la información que se tiene sobre entidades relevantes, que actualmente se encuentra almacenada en diversos sistemas de la Universidad. Para esto se unifican los registros correspondientes y se almacena el registro consolidado (golden record), junto a las llaves necesarias para acceder a los registros originales, en el schema MDIUC.\nEl pipeline del proceso de la malla MDM se encuentra en la ruta Fase 1/NORMALIZADO/MCP_MDIUC de la rama feature_mcp_mdiuc.\nPipelines de la malla MDM #  Los pipelines que utiliza la malla MDM se detallan a continuación.\nMCP_MDIUC #  Este pipelines revisa cuáles son las entidades maestras a procesar, registradas en la tabla dev_stage_datagov.MCP_MDIUC.ENTITY, cada una de las cuales se procesa en el pipeline PROCESS_ENTITY\nPROCESS_ENTITY #  Verifica si se trata de una entidad que tiene una fuente oficial de datos. Si la tiene, se ejecuta el pipeline ENTITY_WITH_OFFICIAL_SOURCE\nENTITY_WITH_OFFICIAL_SOURCE #  Ejecuta el Databricks Notebook match_with_official_source, que registra el mapeo de una entidad con el registro de la fuente oficial en la tabla dev_stage_datagov.MDIUC.\u0026lt;entityName\u0026gt;_TRANSLATION. Si no existe un dato oficial que calce con un registro, este útlimo se ingresa en la tabla dev_stage_datagov.MDIUC.UNMATCHED_\u0026lt;entityName\u0026gt;.\nLas reglas para encontrar pares entre los sistemas se encuentran en el Databricks Notebook.\nENTITY_WITHOUT_OFFICIAL_SOURCE #    Prepara las tablas auxiliares que se utilizarán en el proceso. Las tablas viven en la BD dev_stage_datagov y son las siguientes:\n   Tabla Descripción     MCP_MDIUC.PROCESSING_\u0026lt;entityName\u0026gt; almacena los datos agrupados de distintos orígenes   MCP_MDIUC.PROCESSED_\u0026lt;entityName\u0026gt; almacena los registros procesados que serán ingresados en el golden record   MCP_MDIUC.INVALID_GROUP_\u0026lt;entityName\u0026gt; almacena los id de los grupos que no son válidos, es decir, no corresponden a la misma entidad      Copia los datos de distintos orígenes a la tabla MCP_MDIUC.PROCESSING_\u0026lt;entityName\u0026gt;.\n  Asigna un id de grupo a los registros de MCP_MDIUC.PROCESSING_\u0026lt;entityName\u0026gt; utilizando los criterios en la tabla MCP_MDIUC.GROUPING_RULE.\n  Identifica si el grupo no necesita ser validado. Esto puede ocurrir porque el grupo o bien contiene un solo registro, o porque los registros dentro del grupo son totalmente iguales.\n  Mueve los registros que no necesitan ser validados a la tabla MCP_MDIUC.PROCESSED_\u0026lt;entityName\u0026gt;.\n  Procesa los grupos que necesitan ser validados en el Databricks Notebook Verify Groups. Este Notebook se encarga de escribir en las tablas MCP_MDIUC.PROCESSED_\u0026lt;entityName\u0026gt; y MCP_MDIUC.INVALID_GROUP_\u0026lt;entityName\u0026gt; utilizando los criterios de la tabla MCP_MDIUC.GROUPING_RULE.\n  Actualiza los datos del golden record en el esquema dev_stage_datagov.MDIUC según los nuevos datos recién procesados en la tabla MCP_MDIUC.PROCESSED_\u0026lt;entityName\u0026gt;.\n  Diagrama de los procesos de la malla MDM #  Los procesos asociados a la malla MDM se muestran en la siguiente imagen:\nTablas utilizadas en el proceso de la malla MDM #  A continuación, las tablas utilizadas en el proceso. Las tablas viven en el esquema dev_stage_datagov.MCP_MDIUC.\nENTITY #  Tabla con las entidades de registros maestros que se procesan en la malla MDM.\n   Atributo Descripción     entity_id id único de una entidad   name nombre de la entidad (igual al nombre de la tabla en el esquema dev_stage_datagov.MDIUC)   is_valid indica si se debe procesar una entidad al ejecutar la malla   has_oficcial_source indica si el procesamiento de una entidad requiere de datos externos (fuente oficial de datos)    ENTITY_ATTRIBUTE #  Registra los atributos que se almacenan en el golden record de una entidad.\n   Atributo Descripción     entity_attribute_id id único del registro   entity_id id de la entidad de la tabla MCP_MDIUC.ENTITY a la que se hace referencia   attribute_name nombre del atributo de la entidad en MCP_MDIUC.ENTITY   attribute_type tipo de dato del atributo; puede ser int, nvarchar o datetime   is_primary_key indica si el atributo es parte de la primary key de la entidad en su tabla en dev_stage_datagov.MDIUC    ENTITY_SYSTEM_TABLE #  Registra los atributos que se almacenan en el golden record de una entidad.\n   Atributo Descripción     entity_system_table_id id único del registro   entity_id id de la entidad de la tabla MCP_MDIUC.ENTITY a la que se hace referencia   schema_name nombre del esquema en el que se encuentra la tabla   table_name nombre de la tabla que almacena los registros de una entidad   primary_key primary key de la tabla en table_name; se utiliza para hacer referencia entre el registro y el golden record    ENTITY_ATTRIBUTE_SYSTEM_MAPPING #  Registra los atributos que se almacenan en el golden record de una entidad.\n   Atributo Descripción     entity_attribute_system_mapping_id id único del registro   entity_attribute_id id de un atributo del golden record que hace referencia a MCP_MDIUC.ENTITY_ATTRIBUTE   entity_system_table_id id de la tabla que contiene información sobre la entidad; hace referencia a MCP_MDIUC.ENTITY_SYSTEM_TABLE   column_name nombre de la columna del atributo deseado   attribute_rank prioridad del origen del atributo al momento de armar el golden record    GROUPING_RULE #  Describe los atributos que se utilizarán para agrupar posibles registros que corresponden a la misma entidad.\nSi se ingresan los atributos A, B y C, los registros que tengan el mismo valor en el atributo A, el mismo valor en el atributo B y el mismo valor en el atributo C, se agruparán.\n   Atributo Descripción     grouping_rule_id id único del registro   entity_attribute_id id del atributo que se utiliza en la agrupación; hace referencia a MCP_MDIUC.ENTITY_ATTRIBUTE    COMPARING_RULE #  Describe las reglas que aplicarán durante la comparación de los registros de un mismo grupo para determinar si corresponden a la misma entidad.\n   Atributo Descripción     comparing_id id único del registro   entity_attribute_id id del atributo utilizado en la comparación; hace referencia a MCP_MDIUC.ENTITY_ATTRIBUTE   rule_type tipo de regla que se aplica sobre los valores durante la comparación   parameter parámetros que puedan necesitar el tipo de comparación   process procesamiento que necesiten los atributos a comparar    Para el atributo rule_type existen tres rglas de comparación:\n   Regla Descripción     exact ambos atributos deben ser exactamente iguales   fuzzy compara atributos utilizando el algoritmo distancia de edición. En parameter se ingresa el porcentaje de diferencia mínimo necesario para el match   fuzzy_allow_empty mismo comportamiento que fuzzy, pero, adicionalmente, considera una comparación positiva al comparar con un valor nulo    Para el atributo process existe solo un valor posible:\n   Regla Descripción     concat antes de realizar la comparación, concatena todos los valores que tengan el atributo concat en el campo process. Por ejemplo, si los atributos A, B, C tiene el valor concat en el campo process, al momento de comparar la comparación no se hará de manera individual; la comparación se realizará con el valor resultante de la concatenación de A, B y C. Los valores nulos se consideran strings vacíos    VALIDATION_TYPE #  Describe los tipos de validación que se deben realizar a los grupos que podrían corresponder a la misma entidad.\n   Atributo Descripción     validation_type_id id del registro   name descripción del registro    Actualmente se registran 3 tipos de validaciones:\n Databricks notebook: indica que el grupo debe ser revisado por el proceso de Databricks. Move directly. All rows same row: indica que el grupo contiene exactamente los mismos atributos o si solo se compone de un registro, por lo que no son necesarias más validaciones. Se puede trasladar directamente. Resolved manually: indica que el grupo coincide con un caso resuelto previamente de forma manual, por lo que no se deben realizar más validaciones y se debe trasladar el registro resuelto.  Tablas utilizadas por entidad #  PROCESSING_\u0026lt;entityName\u0026gt; #  Para entidades sin fuente oficial. En esta tabla se ingresan los datos de las distintas fuentes descritas en MCP_MDIUC.ENTITY_SYSTEM_TABLE.\n   Atributo Descripción     group_id id utilizado para agrupar distintos registros que potencialmente corresponden a la misma entidad   validation_type_id tipo de validación que se debe realizar. Referencia a MCP_MDIUC.VALIDATION_TYPE   entity_system_table_id id de la tabla fuente de la que se extrajo el registro   primary_key llave primaria del registro en la fuente de origen   \u0026lt;atributo_entidad_1\u0026gt; este atributo (y los siguientes) corresponden a los atributos de la entidad en MCP_MDIUC.ENTITY_ATTRIBUTE    PROCESSED_\u0026lt;entityName\u0026gt; #  Para entidades sin fuente oficial. En esta tabla se guardan los registros que representan a cada grupo de MCP_MDIUC.PROCESSING_\u0026lt;entityName\u0026gt;.\n   Atributo Descripción     group_id id del grupo. Utilizado para identificar a qué registros de PROCESSING_\u0026lt;ENTITY\u0026gt;   está representanto este registro    \u0026lt;atributo_entidad_1\u0026gt; este atributo (y los siguientes) corresponden a los atributos de la entidad en MCP_MDIUC.ENTITY_ATTRIBUTE    UNMATCHED_\u0026lt;entityName\u0026gt; #  En esta tabla se registran los IDs de los grupos que no cumplieron con las reglas de comparación descritas en COMPARING_RULE y que, por lo tanto, necesitan una revisión manual.\n   Atributo Descripción     group_id id del grupo. Utilizado para identificar a qué registros de PROCESSING_\u0026lt;ENTITY\u0026gt;   no cumplieron con las reglas de comparación     CONFLICTIVE_\u0026lt;entityName\u0026gt; #  Para entidades sin fuente oficial .En esta tabla se almacenan los registros con los datos de la fuente oficial del grupo que fue resuelto manualmente.\n   Atributo Descripción     conflicted_\u0026lt;entityName\u0026gt;_id id del registro   group_id id que agrupa los registros que corresponden a la misma entidad   entity_system_table_id id de la tabla fuente de la que se extrajo el registro. Referencia a MCP_MDIUC.ENTITY_SYSTEM_TABLE   \u0026lt;attributo_entitidad_1\u0026gt; este atributo y los siguientes corresponden a los atributos de la entidad descritos en ENTITY_ATTRIBUTE.    RESOLUTION_\u0026lt;entityName\u0026gt; #  En esta tabla se almacenan la información de resoluciones manuales de las entidades. Esta tabla puede tener dos estructuras:\nEntidad sin fuente oficial #  En esta tabla se almacena el registro al cuál se resuelve desde el grupo almacenado en CONFLICTIVE_\u0026lt;entityName\u0026gt;.\n   Atributo Descripción     conflicted_\u0026lt;entityName\u0026gt;_id id del registro   group_id id que agrupa los registros que corresponden a la misma entidad   entity_system_table_id id de la tabla fuente de la que se extrajo el registro. Referencia a MCP_MDIUC.ENTITY_SYSTEM_TABLE   \u0026lt;attributo_entitidad_1\u0026gt; este atributo y los siguientes corresponden a los atributos de la entidad descritos en ENTITY_ATTRIBUTE.    Entidad con fuente oficial #  En esta tabla se almacena la referencia a la tabla de origen del registro y a cuál corresponde en la tabla oficial.\n   Atributo Descripción     conflicted_\u0026lt;entityName\u0026gt;_id id del registro   entity_system_table_id id de la tabla fuente de la que se extrajo el registro. Referencia a MCP_MDIUC.ENTITY_SYSTEM_TABLE   pk_source valor de la llave primaria en la tabla de origen correspondiente a entity_system_table_id   pk_official_source valor de la llave primaria en la tabla maestra correspondiente a la entidad    Pasos para ingresar una entidad a la malla MDM #     Paso Descripción     0 Paso previo a la malla. Se debe crear la tabla de la entidad en el esquema dev_stage_datagov.MDIUC que es donde se guardarán los datos al finalizar los procesos de la malla   1 Ingresar los datos de la entidad a MCP_MDIUC.ENTITY   2 Ingresar datos de los atributos a MCP_MDIUC.ENTITY_ATTRIBUTE   3 Ingresar datos de las tablas que se deben revisar a MCP_MDIUC.ENTITY_SYSTEM_TABLE   4 ngresar equivalencia entre los atributos de las tablas y la entidad a MCP_MDIUC.ENTITY_ATTRIBUTE_SYSTEM_MAPPING   5 Ingresar reglas de agrupación a MCP_MDIUC.GROUPING_RULE   6 Ingresar reglas de comparación a MCP_MDIUC.COMPARING_RULE   7 Ejecutar malla en Azure DataFactory MCP_MDIUC    Al ejecutar la malla se crearán las siguientes tablas si es que no existen previamente:\n MCP_MDIUC.PROCESSING_\u0026lt;entityName\u0026gt; MCP_MDIUC.PROCESSED_\u0026lt;entityName\u0026gt; MCP_MDIUC.UNMATCHED_\u0026lt;entityName\u0026gt; MCP_MDIUC.CONFLICTIVE_\u0026lt;entityName\u0026gt; MCP_MDIUC.RESOLUTION_\u0026lt;entityName\u0026gt;  Resolución manual de conflictos #  Para ingresar los casos resueltos manualmente a la malla MDM se utilizan las tablas MCP_MDIUC.CONFLICTIVE_\u0026lt;entityName\u0026gt; (en casos de entidades sin fuente oficial) y MCP_MDIUC.RESOLUTION_\u0026lt;entityName\u0026gt;.\nPara entidades sin fuente oficial #    La malla revisa si alguno de los grupos en PROCESSING_\u0026lt;entityName\u0026gt; existe también en CONFLICTIVE_\u0026lt;entityName\u0026gt;.\n  Si un grupo existe, marca el grupo en PROCESSING_\u0026lt;entityName\u0026gt; con validation_type_id = 3 para que no sea procesado por los siguientes pasos de la malla (SP o Databricks).\n  Copia el registro correspondiente al grupo desde RESOLUTION_\u0026lt;entityName\u0026gt;.\n  Para entidades con fuente oficial #    El script en Databricks revisa si el registro de la fuente oficial que está siendo procesado coincide con alguno en RESOLUTION_\u0026lt;entityName\u0026gt; utilizando el atributo pk_source.\n  Si el registro existe, simplemente se utiliza el registro oficial identificado con pk_official_source como la traducción desde la fuente de origen en la tabla maestra.\n  Pruebas de la malla #  Para probar la malla existen dos entidades:\n MDIUC.PERSON_TEST MDIUC.COUNTRY  PERSON_TEST #  Corresponde a una versión reducida de PERSON. Sus tablas de origen son:\n NORMALIZADO_TEST.PERSON_BANNER NORMALIZADO_TEST.PERSON_PEOPLE_SOFT  Cada tabla contiene el RUT, dígito verificador, apellido paterno y materno, y el nombre. Los registros de estas tablas de extrajeron de Banner y PeopleSoft respectivamente.\nCada tabla contiene 90 registros. Existen 100 RUTs que aparecen en ambas tablas. De ellos:\n  Hay 5 personas con el mismo RUT pero distintos nombres entre PERSON_BANNER y PERSON_PEOPLE_SOFT (personas distintas). Para una de ellas, existe una resolución manual en las tablas CONFLICTIVE_PERSON_TEST y RESOLUTION_PERSON_TEST.\n  Hay 10 personas con el mismo RUT pero con el nombre un poco distinto entre PERSON_BANNER y PERSON_PEOPLE_SOFT (misma persona).\n  Hay 65 personas con mismo RUT y mismo nombre entre PERSON_BANNER y PERSON_PEOPLE_SOFT.\n  COUNTRY #  Esta entidad con fuente oficial hace referencia a las tablas:\n UC_BANNER.PAIS NORMALIZADO_PEOPLE_SOFT.COUNTRY  "}),a.add({id:15,href:'/etl/monitoreo/',title:"Monitoreo",section:"ETL",content:""}),a.add({id:16,href:'/sistemas/admision/',title:"Admision",section:"SISTEMAS",content:""}),a.add({id:17,href:'/sistemas/banner/',title:"Banner",section:"SISTEMAS",content:"  Metadata   "}),a.add({id:18,href:'/sistemas/peoplesoft/',title:"Peoplesoft",section:"SISTEMAS",content:"  "}),a.add({id:19,href:'/azure/',title:"AZURE",section:"Introduction",content:""}),a.add({id:20,href:'/etl/operacion/cargatabla/',title:"Carga de tablas",section:"Operación",content:"Carga de tablas cuando el owner existe en MCP_CATALOGO #  A continuación, se ilustra cómo cargar las tablas ETNIA, INDICE_VULNER_ESCOLAR y POSTUL desde el esquema ADMISION de la BD Stage-Datagov_Prod hacia la BD Sandbox-Datagov_Prod. Ambas BDs viven en el server datagov-uc.\nPaso 1 #  Primero, vemos la última fecha de actualización de las tablas de interés para corroborar que no sea la del día en el que se hará la carga. Para ello corremos el script:\nSELECT * FROM MCP.MCP_FECHA_PROCESO WHERE ID_CATALOGO IN ( SELECT ID_CATALOGO FROM MCP.MCP_CATALOGO WHERE NOMBRE_TABLA IN (\u0026#39;ETNIA\u0026#39;, \u0026#39;INDICE_VULNER_ESCOLAR\u0026#39;, \u0026#39;POSTUL\u0026#39;) AND NOMBRE_OWNER = \u0026#39;ADMISION\u0026#39; ) Paso 2 #  Luego, seteamos la última y la próxima fecha de actulización de las tablas, tanto para la malla ADL como para la malla STG:\nUPDATE MCP.MCP_FECHA_PROCESO SET FCH_ULT_ACTUALIZACION_STG = \u0026#39;1900-01-01\u0026#39; , FCH_ULT_ACTUALIZACION_ADL = \u0026#39;1900-01-01\u0026#39; , FCH_PROX_ACTUALIZACION_STG = \u0026#39;2021-02-04\u0026#39; -- Fecha del día en que hacemos la carga  , FCH_PROX_ACTUALIZACION_ADL = \u0026#39;2021-02-04\u0026#39; -- Fecha del día en que hacemos la carga WHERE ID_CATALOGO IN ( SELECT ID_CATALOGO FROM MCP.MCP_CATALOGO WHERE NOMBRE_TABLA IN (\u0026#39;ETNIA\u0026#39;, \u0026#39;INDICE_VULNER_ESCOLAR\u0026#39;, \u0026#39;POSTUL\u0026#39;) AND NOMBRE_OWNER = \u0026#39;ADMISION\u0026#39; ) Paso 3 #  Antes de ir a DataFactory y ejecutar los pipelines, debemos asegurarnos que las tablas a cargar estén en la tabla SBX.CARGA_TABLA_STG_A_SBX. Para ellos corremos lo siguiente:\nSELECT * FROM SBX.CARGA_TABLA_STG_A_SBX WHERE NOMBRE_TABLA IN (\u0026#39;ETNIA\u0026#39;, \u0026#39;INDICE_VULNER_ESCOLAR\u0026#39;, \u0026#39;POSTUL\u0026#39;) AND NOMBRE_OWNER = \u0026#39;ADMISION\u0026#39; Es de esperar que la query no arroje resultados. Por lo que debemos agregar las tablas que se cargarán:\nINSERT INTO SBX.CARGA_TABLA_STG_A_SBX (NOMBRE_OWNER, NOMBRE_TABLA, FLG_SBX) VALUES (\u0026#39;ADMISION\u0026#39;, \u0026#39;ETNIA\u0026#39;, 1) , (\u0026#39;ADMISION\u0026#39;, \u0026#39;INDICE_VULNER_ESCOLAR\u0026#39;, 1) , (\u0026#39;ADMISION\u0026#39;, \u0026#39;POSTUL\u0026#39;, 1) Notemos que solo ingresamos los datos relevantes.\nPaso 4 #  Una vez ejecutados estos pasos, se ejecutan las mallas ADL, STG y SBX en el Azure Data Factory. La Ejecución debe ser secuencial:\nMalla ADL ➡️ Malla STG ➡️ Malla SBX\nFinalmente, y desde la BD Sandbox-Datagov_Prod, corremos lo siguiente para asegurarnos que las tablas se cargaron:\nSELECT [name] , create_date , modify_date , schema_id , schema_name(schema_id) FROM sys.objects WHERE schema_name(schema_id) = \u0026#39;ADMISION\u0026#39; AND CAST(create_date AS DATE) = \u0026#39;2021-02-04\u0026#39; "}),a.add({id:21,href:'/catalogo-uc/',title:"CATÁLOGO",section:"Introduction",content:"Catálogo UC #  Los catálogos de datos son herramientas esenciales para la administración, la conservación y el gobierno de datos (data governance). Se definen para un uso estratégico, muy útiles para la gestión de activos de datos y para mejorar la calidad y la productividad de los análisis. Así también facilitan la identificación, comprensión y colaboración entre datos y las reglas de negocio a nivel global.\nLos objetivos del catálogo concretamente son:\n Entregar y unificar información técnica, operacional y de negocio de los datos mediante una plataforma web. Permitir navegar de forma intuitiva el modelo MDI y su conexión con el DWI, y este último con los sistemas de origen para obtener una trazabilidad completa. Entregar información mediante la capa de servicios.  Producción #   Front-end: https://appcatalogouc-front.azurewebsites.net/ Back-end: https://appcatalogouc-back.azurewebsites.net/docs  Desarollo #   Front-end: https://appcatalogouc-front-dev.azurewebsites.net/ Back-end: https://appcatalogouc-back-dev.azurewebsites.net/docs  "}),a.add({id:22,href:'/utils/columntypes/',title:"Columns Types",section:"UTILS",content:"Data type de las columnas de una tabla #  Para conocer los tipos, y el tamaño de una tabla particular, utilizamos la siguiente query:\nSELECT [Name] = c.[name] , [Type] = CASE WHEN tp.[name] IN (\u0026#39;varchar\u0026#39;, \u0026#39;char\u0026#39;, \u0026#39;varbinary\u0026#39;) THEN tp.[name] + \u0026#39;(\u0026#39; + IIF(c.max_length = -1, \u0026#39;max\u0026#39;, CAST(c.max_length AS VARCHAR(25))) + \u0026#39;)\u0026#39; WHEN tp.[name] IN (\u0026#39;nvarchar\u0026#39;,\u0026#39;nchar\u0026#39;) THEN tp.[name] + \u0026#39;(\u0026#39; + IIF(c.max_length = -1, \u0026#39;max\u0026#39;, CAST(c.max_length / 2 AS VARCHAR(25))) + \u0026#39;)\u0026#39; WHEN tp.[name] IN (\u0026#39;decimal\u0026#39;, \u0026#39;numeric\u0026#39;) THEN tp.[name] + \u0026#39;(\u0026#39; + CAST(c.[precision] AS VARCHAR(25)) + \u0026#39;, \u0026#39; + CAST(c.[scale] AS VARCHAR(25)) + \u0026#39;)\u0026#39; WHEN tp.[name] IN (\u0026#39;datetime2\u0026#39;) THEN tp.[name] + \u0026#39;(\u0026#39; + CAST(c.[scale] AS VARCHAR(25)) + \u0026#39;)\u0026#39; ELSE tp.[name] END , [RawType] = tp.[name] , [MaxLength] = c.max_length , [Precision] = c.[precision] , [Scale] = c.scale FROM sys.tables t JOIN sys.schemas s ON t.schema_id = s.schema_id JOIN sys.columns c ON t.object_id = c.object_id JOIN sys.types tp ON c.user_type_id = tp.user_type_id WHERE s.[name] = \u0026#39;\u0026lt;nombreEsquema\u0026gt;\u0026#39; AND t.[name] = \u0026#39;\u0026lt;nombreTabla\u0026gt;\u0026#39; Donde\n \u0026lt;nombreEsquema\u0026gt;: es el nombre del esquema \u0026lt;nombreTabla: es el nombre de la tabla  "}),a.add({id:23,href:'/mdi/ficha-academica/docencia/',title:"Docencia y formación de personas",section:"Ficha Academica",content:"Tablas y cruces propuestos #  Cruce académicos y cursos dictados #  WITH CURSODICTADO AS ( SELECT HPHC.COD_PERS AS COD_PERS , HPHC.RUT AS RUT , ACA.NOMBRE_COMPLETO AS NOMBRE_COMPLETO , HC.COD_HIST_CURSO AS COD_HIST_CURSO , HC.ANO_CURSO AS ANO_CURSO , HC.SECCION AS SECCION_CURSO , HC.SIGLA AS SIGLA_CURSO , CU.NOM_CURSO AS NOMBRE_CURSO FROM UC_BANNER.R_HIST_PERS_HIST_CURSO AS HPHC JOIN UC_BANNER.HIST_CURSO AS HC ON HPHC.COD_HIST_CURSO = HC.COD_HIST_CURSO JOIN UC_BANNER.CURSO AS CU ON HC.SIGLA = CU.SIGLA JOIN web.Academicos_sipa AS ACA ON HPHC.RUT = ACA.RUT GROUP BY HPHC.COD_PERS , HPHC.RUT , ACA.NOMBRE_COMPLETO , HC.COD_HIST_CURSO , HC.ANO_CURSO , HC.SECCION , HC.SIGLA , CU.NOM_CURSO ) SELECT COUNT(DISTINCT COD_PERS) FROM CURSODICTADO -- este cruce entrega 2993 personas distintas  SELECT COUNT(DISTINCT COD_PERS) FROM web.Academicos_sipa -- esta vista indica que hay 3575 académicos Perfil de los datos generados:\n Años de los cursos desde 1991 - 2019 2993 académicos distintos 5048 cursos distintos Desde el 2016 en adelante, más de 3000 cursos por año  Cruce académicos y actividad académica #  WITH ACTIVACAD AS ( SELECT HPHC.COD_PERS AS COD_PERS , HPHC.RUT AS RUT , WAS.NOMBRE_COMPLETO AS NOMBRE_COMPLETO , HA.NOM_ACTIV_ACADEMICO AS NOMBRE_ACTIVIDAD_ACADEMICA , HA.COD_TIPO_ACTIV_ACADEMICO AS COD_TIPO_ACTIV_ACADEMICA , HATA.NOM_TIPO_ACTIV_ACADEMICO AS NOMBRE_TIPO_ACTIV_ACADEMICA -- , HATA.INTERNO_UC  , HATA.VIG_TIPO_ACTIV_ACADEMICO AS ACTIV_ACADEMICA_VIGENTE , CAST(HA.FECHA_INICIO AS DATE) AS FECHA_INICIO_ACTIV , CAST(HA.FECHA_FIN AS DATE) AS FECHA_FIN_ACTIV , HA.DESCRIP_ABREV_ACTIV AS DESCRIP_ABREV_ACTIV FROM HISTACADEMICO.ACTIV_ACADEMICO AS HA JOIN UC_BANNER.R_HIST_PERS_HIST_CURSO AS HPHC ON HA.COD_PERS = HPHC.COD_PERS JOIN web.Academicos_sipa AS WAS ON HPHC.RUT = HAU.RUT JOIN HISTACADEMICO.TIPO_ACTIV_ACADEMICO AS HATA ON HA.COD_TIPO_ACTIV_ACADEMICO = HATA.COD_TIPO_ACTIV_ACADEMICO GROUP BY HPHC.COD_PERS , HPHC.RUT , WAS.NOMBRE_COMPLETO , HA.NOM_ACTIV_ACADEMICO , HA.COD_TIPO_ACTIV_ACADEMICO , HATA.NOM_TIPO_ACTIV_ACADEMICO -- , HATA.INTERNO_UC  , HATA.VIG_TIPO_ACTIV_ACADEMICO , CAST(HA.FECHA_INICIO AS DATE) , CAST(HA.FECHA_FIN AS DATE) , HA.DESCRIP_ABREV_ACTIV ) SELECT * FROM ACTIVACAD --1061 Perfil de los datos generados:\n 1061 académicos distintos  "}),a.add({id:24,href:'/etl/',title:"ETL",section:"Introduction",content:"El proceso de ETL como su nombre lo dice, permite extraer transformar y cargar información desde multiples origenes y hacer uso de ellos.\n"}),a.add({id:25,href:'/utils/mapeofk/',title:"Mapeo de FK",section:"UTILS",content:"Mapero de FK #  Usamos el siguiente system util para ver la información relativa a la tabla. Al final aparecen las FK:\nUSE \u0026lt;dataBaseName\u0026gt;; GO EXEC sp_help N\u0026#39;\u0026lt;dataBaseName.schemaName.tableName\u0026gt;\u0026#39;; "}),a.add({id:26,href:'/sql/queries/',title:"Queries",section:"SQL",content:""}),a.add({id:27,href:'/utils/resultjson/',title:"Resultado de query en JSON",section:"UTILS",content:"Queries que muestran el resultado en JSON #   Resultado con top-level element:  SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = \u0026#39;\u0026lt;tableName\u0026gt;\u0026#39; FOR JSON PATH, ROOT(\u0026#39;\u0026lt;topLevelElementeName\u0026gt;\u0026#39;) Resultado sin top-level element:  SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = \u0026#39;\u0026lt;tableName\u0026gt;\u0026#39; FOR JSON PATH Resultado que entrega la misma estructura que la del SELECT statement:  SELECT TABLE_SCHEMA , TABLE_NAME , COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = \u0026#39;\u0026lt;tableName\u0026gt;\u0026#39; FOR JSON AUTO "}),a.add({id:28,href:'/utils/rowcount/',title:"Row count",section:"UTILS",content:"Row count de las tablas de un esquema en particular #  Para generar una tabla con el número de registros por tabla según esquema, ejecutamos la siguiente query:\nWITH [RowCount] AS ( SELECT SCHEMA_NAME(t.schema_id) AS [schema_name] , t.name AS table_name , s.row_count FROM sys.tables t JOIN sys.dm_db_partition_stats s ON t.object_id = s.object_id AND t.type = \u0026#39;U\u0026#39; AND t.name NOT LIKE \u0026#39;%dss%\u0026#39; AND s.index_id IN (0, 1) ) SELECT * FROM [RowCount] WHERE [schema_name] = \u0026#39;\u0026lt;nombreEsquema\u0026gt;\u0026#39; AND row_count \u0026lt;\u0026gt; 0 ORDER BY [schema_name], row_count DESC "}),a.add({id:29,href:'/sistemas/',title:"SISTEMAS",section:"Introduction",content:""}),a.add({id:30,href:'/sql/',title:"SQL",section:"Introduction",content:""}),a.add({id:31,href:'/utils/viewtableusage/',title:"Tablas consumidas por una vista",section:"UTILS",content:"Query para revisar las tablas que consume una vista #  La siguente query muesta las tablas con las que se construye una vista:\nSELECT * FROM INFORMATION_SCHEMA.VIEW_TABLE_USAGE WHERE VIEW_NAME = \u0026#39;\u0026lt;tableName\u0026gt;\u0026#39; "})})()