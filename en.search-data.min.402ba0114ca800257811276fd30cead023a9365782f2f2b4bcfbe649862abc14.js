'use strict';(function(){const b={cache:!0};b.doc={id:'id',field:['title','content'],store:['title','href','section']};const a=FlexSearch.create('balance',b);window.bookSearchIndex=a,a.add({id:0,href:'/azure/give-access/',title:"Accesos a BD",section:"AZURE",content:"1. perfilamiento de accesos a en base de datos (Authorization) #  1.1 Acceso para un grupo de AAD #  GRANTALTERONSCHEMA::[web]TO[g_magnet];GRANTSELECTONSCHEMA::[web]TO[g_magnet];GRANTCONTROLONSCHEMA::[web]TO[g_magnet];GRANTCREATEPROCEDUREto[g_magnet];1.2 Acceso para un usuario de AAD #  GRANTALTERONSCHEMA::[web]TO[usuario1@uc.cl];GRANTSELECTONSCHEMA::[web]TO[usuario1@uc.cl];GRANTCONTROLONSCHEMA::[web]TO[usuario1@uc.cl];GRANTCREATEPROCEDUREto[usuario1@uc.cl];GRANTCREATEVIEWTO[usuario1@uc.cl];1.3 Acceso para un usuario con autenticación SQL-login #  1.4 Para comprobar accesos #  EXECUTEASUSER=\u0026#39;usuario1@uc.cl\u0026#39;"}),a.add({id:1,href:'/azure/apisipa/',title:"API SIPA",section:"AZURE",content:"HOW-TO #  La API se llama a través de un HTTP trigger desplegado en la siguiente ruta:\nhttps://apidwuc.azurewebsites.net/\nY cuyos endpoints para las consultas de acádemicos y unidades académicas son los siguientes:\n   Objeto de consulta Endpoint Descripción     Unidades académicas /uas Devuelve el total de las unidades académicas de la universidad.   Unidad académica /ua/\u0026lt;id unidad académica\u0026gt; Devuelve una unidad académica en según el ID de esta, donde \u0026lt;id unidad académica\u0026gt; es el número (ID) de la unidad académica. El link redirecciona a la unidad académica con \u0026lt;id unidad académica\u0026gt; = 1 para ilustrar.   Académicos /academicos Devuelve la totalidad de los académicos.   Académicos por código de persona /academicos_codper/\u0026lt;cod_per\u0026gt; Devuelve un académico según su código de persona. El link redirecciona al académico con \u0026lt;cod_per\u0026gt; = 163754 para ilustrar.   Académicos por usuario UC /academicos_usuario/\u0026lt;usuario_uc\u0026gt; Devuelve un académico según su usuario UC. El link redirecciona al académico con \u0026lt;usuario_uc\u0026gt; = xdarriet para ilustrar.    "}),a.add({id:2,href:'/sql/Modelo-DAC/Configuraci%C3%B3n-DAC/',title:"Configuración DAC",section:"DAC",content:"Discretionary access control (DAC)\nPara poder revisar las politicas ya aplicadas dirigirse a la sección de monitoring XX:\nPor otro lado para configurar un nuevo permiso o acceso se debe realizar lo siguiente:\n1. Realizar inserciones tablas DM, GD, DC #  listado de tablas y scripts de ejemplo de inserciones.\n2. Ejecutar pipeline de modelo DAC (para aplicar politicas) #  foto del adf\n3. Verificar que se han aplicado accesos #  Execute as user etc\u0026hellip;\n"}),a.add({id:3,href:'/azure/create-user/',title:"Creación usuarios",section:"AZURE",content:"Cómo crear usuarios y roles en Bases de Datos con AAD auth #  Estructura estándar #   Cómo ver qué usuarios tienen accesos. A qué objeto tiene acceso un usuario. Cómo añadir un usuario nuevo a un grupo en AAD existente.  Cómo añadir al grupo AAD en SQL.    1. Crear usuario #  1.1 Autenticación: SQL login #  CREATELOGINMaryUserWITHPASSWORD=\u0026#39;8YpFWHhrWUgTTbED\u0026#39;;CREATEUSERMaryUserFROMLOGINMaryUser;-- son 2 veces, uno en la master y otro en tu BD ALTERROLEdb_datareaderADDMEMBERMaryUser;-- en tu BD ALTERROLEdb_ddladminADDMEMBERMaryUser;ALTERROLEdb_datawriterADDMEMBERMaryUser;1.2 Autenticación: AAD #  CREATEUSER[g_magnet]FROMEXTERNALPROVIDER;1.2 Verificación de usuarios #  SELECTnameASusername,create_date,modify_date,type_descastype,authentication_type_descASauthentication_typeFROMsys.database_principalsORDERBYtype_desc;"}),a.add({id:4,href:'/sql/Modelo-DAC/',title:"DAC",section:"SQL",content:""}),a.add({id:5,href:'/etl/mallas/mallamdm/malla-mdm/',title:"HOW-TO",section:"Malla MDM",content:"Malla MDM #  La Malla MDM se encarga de consolidar la información que se tiene sobre entidades relevantes, que actualmente se encuentra almacenada en diversos sistemas de la Universidad. Para esto se unifican los registros correspondientes y se almacena el registro consolidado (golden record), junto a las llaves necesarias para acceder a los registros originales, en el schema MDIUC.\nEl pipeline del proceso de la malla MDM se encuentra en la ruta Fase 1/NORMALIZADO/MCP_MDIUC de la rama feature_mcp_mdiuc.\nPipelines de la malla MDM #  Los pipelines que utiliza la malla MDM se detallan a continuación.\nMCP_MDIUC #  Este pipelines revisa cuáles son las entidades maestras a procesar, registradas en la tabla dev_stage_datagov.MCP_MDIUC.ENTITY, cada una de las cuales se procesa en el pipeline PROCESS_ENTITY\nPROCESS_ENTITY #  Verifica si se trata de una entidad que tiene una fuente oficial de datos. Si la tiene, se ejecuta el pipeline ENTITY_WITH_OFFICIAL_SOURCE\nENTITY_WITH_OFFICIAL_SOURCE #  Ejecuta el Databricks Notebook match_with_official_source, que registra el mapeo de una entidad con el registro de la fuente oficial en la tabla dev_stage_datagov.MDIUC.\u0026lt;entityName\u0026gt;_TRANSLATION. Si no existe un dato oficial que calce con un registro, este útlimo se ingresa en la tabla dev_stage_datagov.MDIUC.UNMATCHED_\u0026lt;entityName\u0026gt;.\nLas reglas para encontrar pares entre los sistemas se encuentran en el Databricks Notebook.\nENTITY_WITHOUT_OFFICIAL_SOURCE #    Este pipeline prepara las tablas auxiliares que se utilizarán en el proceso. Las tablas viven en la BD dev_stage_datagov y son las siguientes:\n   Tabla Descripción     MCP_MDIUC.PROCESSING_\u0026lt;entityName\u0026gt; almacena los datos agrupados de distintos orígenes   MCP_MDIUC.PROCESSED_\u0026lt;entityName\u0026gt; almacena los registros procesados que serán ingresados en el golden record   MCP_MDIUC.INVALID_GROUP_\u0026lt;entityName\u0026gt; almacena los id de los grupos que no son válidos, es decir, no corresponden a la misma entidad      Copia los datos de distintos orígenes a la tabla MCP_MDIUC.PROCESSING_\u0026lt;entityName\u0026gt;.\n  Asigna un id de grupo a los registros de MCP_MDIUC.PROCESSING_\u0026lt;entityName\u0026gt; utilizando los criterios en la tabla MCP_MDIUC.GROUPING_RULE.\n  Identifica si el grupo no necesita ser validado. Esto puede ocurrir porque el grupo o bien contiene un solo registro, o porque los registros dentro del grupo son totalmente iguales.\n  Mueve los registros que no necesitan ser validados a la tabla MCP_MDIUC.PROCESSED_\u0026lt;entityName\u0026gt;.\n  Procesa los grupos que necesitan ser validados en el Databricks Notebook Verify Groups. Este Notebook se encarga de escribir en las tablas MCP_MDIUC.PROCESSED_\u0026lt;entityName\u0026gt; y MCP_MDIUC.INVALID_GROUP_\u0026lt;entityName\u0026gt; utilizando los criterios de la tabla MCP_MDIUC.GROUPING_RULE.\n  Actualiza los datos del golden record en el esquema dev_stage_datagov.MDIUC según los nuevos datos recién procesados en la tabla MCP_MDIUC.PROCESSED_\u0026lt;entityName\u0026gt;.\n  Diagrama de los procesos de la malla MDM #  Los procesos asociados a la malla MDM se muestran en la siguiente imagen:\nTablas utilizadas en el proceso de la malla MDM #  A continuación, las tablas utilizadas en el proceso. Las tablas viven en el esquema dev_stage_datagov.MCP_MDIUC.\nENTITY #  Tabla con las entidades de registros maestros que se procesan en la malla MDM.\n   Atributo Descripción     entity_id id único de una entidad   name nombre de la entidad (igual al nombre de la tabla en el esquema dev_stage_datagov.MDIUC)   is_valid indica si se debe procesar una entidad al ejecutar la malla   has_oficcial_source indica si el procesamiento de una entidad requiere de datos externos (fuente oficial de datos)    ENTITY_ATTRIBUTE #  Registra los atributos que se almacenan en el golden record de una entidad.\n   Atributo Descripción     entity_attribute_id id único del registro   entity_id id de la entidad de la tabla MCP_MDIUC.ENTITY a la que se hace referencia   attribute_name nombre del atributo de la entidad en MCP_MDIUC.ENTITY   attribute_type tipo de dato del atributo; puede ser int, nvarchar o datetime   is_primary_key indica si el atributo es parte de la primary key de la entidad en su tabla en dev_stage_datagov.MDIUC    ENTITY_SYSTEM_TABLE #  Registra los atributos que se almacenan en el golden record de una entidad.\n   Atributo Descripción     entity_system_table_id id único del registro   entity_id id de la entidad de la tabla MCP_MDIUC.ENTITY a la que se hace referencia   schema_name nombre del esquema en el que se encuentra la tabla   table_name nombre de la tabla que almacena los registros de una entidad   primary_key primary key de la tabla en table_name; se utiliza para hacer referencia entre el registro y el golden record    ENTITY_ATTRIBUTE_SYSTEM_MAPPING #  Registra los atributos que se almacenan en el golden record de una entidad.\n   Atributo Descripción     entity_attribute_system_mapping_id id único del registro   entity_attribute_id id de un atributo del golden record que hace referencia a MCP_MDIUC.ENTITY_ATTRIBUTE   entity_system_table_id id de la tabla que contiene información sobre la entidad; hace referencia a MCP_MDIUC.ENTITY_SYSTEM_TABLE   column_name nombre de la columna del atributo deseado   attribute_rank prioridad del origen del atributo al momento de armar el golden record    GROUPING_RULE #  Describe los atributos que se utilizarán para agrupar posibles registros que corresponden a la misma entidad.\nSi se ingresan los atributos A, B y C, los registros que tengan el mismo valor en el atributo A, el mismo valor en el atributo B y el mismo valor en el atributo C, se agruparán.\n   Atributo Descripción     grouping_rule_id id único del registro   entity_attribute_id id del atributo que se utiliza en la agrupación; hace referencia a MCP_MDIUC.ENTITY_ATTRIBUTE    COMPARING_RULE #  Describe las reglas que aplicarán durante la comparación de los registros de un mismo grupo para determinar si corresponden a la misma entidad.\n   Atributo Descripción     comparing_id id único del registro   entity_attribute_id id del atributo utilizado en la comparación; hace referencia a MCP_MDIUC.ENTITY_ATTRIBUTE   rule_type tipo de regla que se aplica sobre los valores durante la comparación   parameter parámetros que puedan necesitar el tipo de comparación   process procesamiento que necesiten los atributos a comparar    Para el atributo rule_type existen tres rglas de comparación:\n   Regla Descripción     exact ambos atributos deben ser exactamente iguales   fuzzy compara atributos utilizando el algoritmo distancia de edición. En parameter se ingresa el porcentaje de diferencia mínimo necesario para el match   fuzzy_allow_empty mismo comportamiento que fuzzy, pero, adicionalmente, considera una comparación positiva al comparar con un valor nulo    Para el atributo process existe solo un valor posible:\n   Regla Descripción     concat antes de realizar la comparación, concatena todos los valores que tengan el atributo concat en el campo process. Por ejemplo, si los atributos A, B, C tiene el valor concat en el campo process, al momento de comparar la comparación no se hará de manera individual; la comparación se realizará con el valor resultante de la concatenación de A, B y C. Los valores nulos se consideran strings vacíos    VALIDATION_TYPE #  Describe los tipos de validación que se deben realizar a los grupos que podrían corresponder a la misma entidad.\n   Atributo Descripción     validation_type_id id del registro   name descripción del registro    Actualmente se registran 3 tipos de validaciones (id = validation_type_id):\n   id Nombre Descripción     1 Databricks notebook indica que el grupo debe ser revisado por el proceso de Databricks   2 Move directly. All rows same row indica que el grupo contiene exactamente los mismos atributos o si solo se compone de un registro, por lo que no son necesarias más validaciones. Se puede trasladar directamente   3 Resolved manually indica que el grupo coincide con un caso resuelto previamente de forma manual, por lo que no se deben realizar más validaciones y se debe trasladar el registro resuelto    Tablas utilizadas por entidad #  PROCESSING_\u0026lt;entityName\u0026gt; #  Para entidades sin fuente oficial. En esta tabla se ingresan los datos de las distintas fuentes descritas en MCP_MDIUC.ENTITY_SYSTEM_TABLE.\n   Atributo Descripción     group_id id utilizado para agrupar distintos registros que potencialmente corresponden a la misma entidad   validation_type_id tipo de validación que se debe realizar. Referencia a MCP_MDIUC.VALIDATION_TYPE   entity_system_table_id id de la tabla fuente de la que se extrajo el registro   primary_key llave primaria del registro en la fuente de origen   \u0026lt;atributo_entidad_i\u0026gt; con i ∈ {1, \u0026hellip; , n}. Corresponden a los atributos de la entidad en MCP_MDIUC.ENTITY_ATTRIBUTE    PROCESSED_\u0026lt;entityName\u0026gt; #  Para entidades sin fuente oficial. En esta tabla se guardan los registros que representan a cada grupo de MCP_MDIUC.PROCESSING_\u0026lt;entityName\u0026gt;.\n   Atributo Descripción     group_id id del grupo. Utilizado para identificar a qué registros de `PROCESSING_está representanto este registro   \u0026lt;atributo_entidad_i\u0026gt; con i ∈ {1, \u0026hellip; , n}. Corresponden a los atributos de la entidad en MCP_MDIUC.ENTITY_ATTRIBUTE    UNMATCHED_\u0026lt;entityName\u0026gt; #  En esta tabla se registran los IDs de los grupos que no cumplieron con las reglas de comparación descritas en COMPARING_RULE y que, por lo tanto, necesitan una revisión manual.\n   Atributo Descripción     group_id id del grupo. Utilizado para identificar a qué registros de PROCESSING_\u0026lt;ENTITY\u0026gt;no cumplieron con las reglas de comparación    CONFLICTIVE_\u0026lt;entityName\u0026gt; #  Para entidades sin fuente oficial .En esta tabla se almacenan los registros con los datos de la fuente oficial del grupo que fue resuelto manualmente.\n   Atributo Descripción     conflicted_\u0026lt;entityName\u0026gt;_id id del registro   group_id id que agrupa los registros que corresponden a la misma entidad   entity_system_table_id id de la tabla fuente de la que se extrajo el registro. Referencia a MCP_MDIUC.ENTITY_SYSTEM_TABLE   \u0026lt;attributo_entitidad_1\u0026gt; este atributo y los siguientes corresponden a los atributos de la entidad descritos en ENTITY_ATTRIBUTE.    RESOLUTION_\u0026lt;entityName\u0026gt; #  En esta tabla se almacenan la información de resoluciones manuales de las entidades. Esta tabla puede tener dos estructuras:\nEntidad sin fuente oficial #  En esta tabla se almacena el registro al cuál se resuelve desde el grupo almacenado en CONFLICTIVE_\u0026lt;entityName\u0026gt;.\n   Atributo Descripción     conflicted_\u0026lt;entityName\u0026gt;_id id del registro   group_id id que agrupa los registros que corresponden a la misma entidad   entity_system_table_id id de la tabla fuente de la que se extrajo el registro. Referencia a MCP_MDIUC.ENTITY_SYSTEM_TABLE   \u0026lt;attributo_entitidad_1\u0026gt; este atributo y los siguientes corresponden a los atributos de la entidad descritos en ENTITY_ATTRIBUTE.    Entidad con fuente oficial #  En esta tabla se almacena la referencia a la tabla de origen del registro y a cuál corresponde en la tabla oficial.\n   Atributo Descripción     conflicted_\u0026lt;entityName\u0026gt;_id id del registro   entity_system_table_id id de la tabla fuente de la que se extrajo el registro. Referencia a MCP_MDIUC.ENTITY_SYSTEM_TABLE   pk_source valor de la llave primaria en la tabla de origen correspondiente a entity_system_table_id   pk_official_source valor de la llave primaria en la tabla maestra correspondiente a la entidad    Pasos para ingresar una entidad a la malla MDM #     Paso Descripción     0 Paso previo a la malla. Se debe crear la tabla de la entidad en el esquema dev_stage_datagov.MDIUC que es donde se guardarán los datos al finalizar los procesos de la malla   1 Ingresar los datos de la entidad a MCP_MDIUC.ENTITY   2 Ingresar datos de los atributos a MCP_MDIUC.ENTITY_ATTRIBUTE   3 Ingresar datos de las tablas que se deben revisar a MCP_MDIUC.ENTITY_SYSTEM_TABLE   4 ngresar equivalencia entre los atributos de las tablas y la entidad a MCP_MDIUC.ENTITY_ATTRIBUTE_SYSTEM_MAPPING   5 Ingresar reglas de agrupación a MCP_MDIUC.GROUPING_RULE   6 Ingresar reglas de comparación a MCP_MDIUC.COMPARING_RULE   7 Ejecutar malla en Azure DataFactory MCP_MDIUC    Al ejecutar la malla se crearán las siguientes tablas si es que no existen previamente:\n MCP_MDIUC.PROCESSING_\u0026lt;entityName\u0026gt; MCP_MDIUC.PROCESSED_\u0026lt;entityName\u0026gt; MCP_MDIUC.UNMATCHED_\u0026lt;entityName\u0026gt; MCP_MDIUC.CONFLICTIVE_\u0026lt;entityName\u0026gt; MCP_MDIUC.RESOLUTION_\u0026lt;entityName\u0026gt;  Resolución manual de conflictos #  Para ingresar los casos resueltos manualmente a la malla MDM se utilizan las tablas MCP_MDIUC.CONFLICTIVE_\u0026lt;entityName\u0026gt; (en casos de entidades sin fuente oficial) y MCP_MDIUC.RESOLUTION_\u0026lt;entityName\u0026gt;.\nPara entidades sin fuente oficial #    La malla revisa si alguno de los grupos en PROCESSING_\u0026lt;entityName\u0026gt; existe también en CONFLICTIVE_\u0026lt;entityName\u0026gt;.\n  Si un grupo existe, marca el grupo en PROCESSING_\u0026lt;entityName\u0026gt; con validation_type_id = 3 para que no sea procesado por los siguientes pasos de la malla (SP o Databricks).\n  Copia el registro correspondiente al grupo desde RESOLUTION_\u0026lt;entityName\u0026gt;.\n  Para entidades con fuente oficial #    El script en Databricks revisa si el registro de la fuente oficial que está siendo procesado coincide con alguno en RESOLUTION_\u0026lt;entityName\u0026gt; utilizando el atributo pk_source.\n  Si el registro existe, simplemente se utiliza el registro oficial identificado con pk_official_source como la traducción desde la fuente de origen en la tabla maestra.\n  "}),a.add({id:6,href:'/internados/admision/indicadores/',title:"Indicadores",section:"Admisión",content:"Sesión de Convergencia: Indicadores Admisión #  A continuación un análisis con los cruces para responder a los indicadores para ADMISIÓN.\n   ID Indicador Definición     1 Admisión especial, según vía de Equidad. Número de postulantes de carreras de pregrado, según vía de equidad, en un año-periodo de admisión.   1 Admisión especial, según vía de Equidad. Número de postulantes-seleccionados a carreras de pregrado, según vía de equidad en un año-periodo de admisión.   1 Admisión especial, según vía de Equidad. Número de estudiantes matriculados en carreras de pregrado , según vía de equidad en un año-periodo de admisión.   2 Estudiantes-postulantes pertenecientes a una etnia. Número de estudiantes pertenecientes a una etnia, por año-periodo de admisión.   3 Postulantes con puntaje nacional, por año-periodo de admisión. Número de estudiantes con puntaje nacional, por año-periodo de admisión.   4 Estudiantes de cursos superiores que postulan a la UC. Número de estudiantes que no vienen directo de un establecimiento de educación secundaria (año de egreso).   5 Estudiantes-Postulantes según nacionalidad por año-periodo de admisión. Número de estudiantres-postulantes según nacionalidad por año-periodo de admisión.   6 Estudiantes-Postulantes, según IVE del establecimiento de origen, por año-periodo de admisión. Número de estudiantes- Postulantes, según IVE del establecimiento de origen, por año-periodo de admisión.   7 Estudiantes, según carreras de preferencia postulada, por año-periodo de admisión. Número de estudiantes seleccionados, según carreras de preferencia postulada por año-periodo de admisión.   7 Estudiantes, según carreras de preferencia postulada, por año-periodo de admisión. Número de estudiantes matriculados, según carreras de preferencia postulada por año-periodo de admisión.   8 Admisión en programas de magister y doctorado. Número de estudiantes: postulantes, aceptados y rechazados en programas de magíster y doctorado por año-periodo de admisión.   8 Admisión en programas de magister y doctorado. Número de matriculados en programas de magíster y doctorado por año-periodo de admisión.    DISCLAIMER\nPara responder a los indicadores en 1, 3 y 8 se debe usar la vista:\nSandobox-Datagov_Prod.ADMISION.TBL_VW_FT_ADMISION_ESP_ORD_PAS Para responder a los indicadores en 2, 4, 5, 6 y 7 se debe usar la vista:\nSandobox-Datagov_Prod.ADMISION.TBL_VW_FT_ADMISION_PAS   1. Admisión especial, según vía de Equidad #  Número de postulantes de carreras de pregrado, según vía de equidad, en un año-periodo de admisión. #  SELECT ANO_ADMIS , NOM_CASO_ADMIS , SEXO , COUNT(1) AS NUM_POSTULANTES FROM ADMISION.TBL_VW_FT_ADMISION_ESP_ORD_PAS WHERE COD_CASO_ADMIS IN (218, 259, 221, 237, 209, 226) GROUP BY ANO_ADMIS , NOM_CASO_ADMIS , SEXO ORDER BY ANO_ADMIS DESC Número de postulantes seleccionados a carreras de pregrado según vía de equidad en un año-periodo de admisión #  SELECT ANO_ADMIS , NOM_CASO_ADMIS , SEXO , COUNT(1) AS NUM_POSTULANTES FROM ADMISION.TBL_VW_FT_ADMISION_ESP_ORD_PAS WHERE COD_CASO_ADMIS IN (218, 259, 221, 237, 209, 226) AND COD_EST_POSTULACION IN (4, 6) OR COD_SIT_POSTULACION = \u0026#39;S\u0026#39; GROUP BY ANO_ADMIS , NOM_CASO_ADMIS , SEXO ORDER BY ANO_ADMIS DESC Número de estudiantes matriculados en carreras de pregrado según vía de equidad en un año-periodo de admisión #  SELECT ANO_ADMIS , NOM_CASO_ADMIS , COD_CASO_ADMIS , SEXO , COUNT(1) AS NUM_POSTULANTES FROM ADMISION.TBL_VW_FT_ADMISION_ESP_ORD_PAS WHERE COD_CASO_ADMIS IN (218, 259, 221, 237, 209, 226) -- estos son todos los códigos que incluye la vía de equidad (el nombre viene en NOM_CASO_ADMIS)  AND (COD_EST_POSTULACION IN (7, 8) -- 7: matriculado, 8: ingresado  OR COD_SIT_POSTULACION IN (\u0026#39;U\u0026#39;, \u0026#39;V\u0026#39;) -- U: matriculado, V: ingresado  ) GROUP BY ANO_ADMIS , NOM_CASO_ADMIS , COD_CASO_ADMIS , SEXO ORDER BY ANO_ADMIS DESC 2. Estudiantes-postulantes pertenecientes a una etnia #  Número de estudiantes pertenecientes a una etnia, por año-periodo de admisión #  SELECT ANO_ADMISION , ETNIA , SEXO , COUNT(1) AS NUM_POSTULANTES FROM ADMISION.TBL_VW_FT_ADMISION_PAS WHERE ETNIA IS NOT NULL AND COD_ETNIA \u0026lt;\u0026gt; 10 GROUP BY ANO_ADMISION , ETNIA , SEXO ORDER BY ANO_ADMISION DESC 3. Postulantes con puntaje nacional por año-periodo de admisión #  Número de estudiantes con puntaje nacional por año-periodo de admisión #  SELECT ANO_ADMIS , SEXO , COUNT(1) AS NUM_POSTULANTES FROM ADMISION.TBL_VW_FT_ADMISION_ESP_ORD_PAS WHERE CIE = 850 OR HYC = 850 OR LYC = 850 OR MAT = 850 GROUP BY ANO_ADMIS , SEXO ORDER BY ANO_ADMIS DESC 4. Estudiantes de cursos superiores que postulan a la UC #  Número de estudiantes que no vienen directo de un establecimiento de educación secundaria (año de egreso) #  SELECT ANO_ADMISION , COUNT(1) AS NUM_POSTULANTES FROM ADMISION.TBL_VW_FT_ADMISION_PAS WHERE (ANO_ADMISION - ANO_EGRESO_COLEGIO) \u0026gt; 1 GROUP BY ANO_ADMISION ORDER BY ANO_ADMISION DESC 5. Estudiantes-Postulantes según nacionalidad por año-periodo de admisión #  Número de estudiantres-postulantes según nacionalidad por año-periodo de admisión #  SELECT ANO_ADMISION , PAIS , COUNT(1) AS NUM_POSTULANTES FROM ADMISION.TBL_VW_FT_ADMISION_PAS GROUP BY ANO_ADMISION , PAIS ORDER BY ANO_ADMISION DESC 6. Estudiantes-Postulantes según IVE del establecimiento de origen, por año-periodo de admisión #  Número de estudiantes-postulantes según IVE del establecimiento de origen, por año-periodo de admisión #  SELECT ANO_ADMISION , IVE_TIER , IVE_TIER_DESC , SEXO , COUNT(1) AS NUM_POSTULANTES FROM ADMISION.TBL_VW_FT_ADMISION_PAS WHERE IVE_COLEGIO IS NOT NULL AND IVE_TIER IS NOT NULL GROUP BY ANO_ADMISION , IVE_TIER , IVE_TIER_DESC , SEXO ORDER BY ANO_ADMISION DESC 7. Estudiantes según carreras de preferencia postulada, por año-periodo de admisión #  Número de estudiantes seleccionados según carreras de preferencia postulada por año-periodo de admisión #  SELECT ANO_ADMISION , CARRERA , PREFERENCIA , COUNT(1) AS NUM_POSTULANTES FROM ADMISION.TBL_VW_FT_ADMISION_PAS WHERE (COD_SIT_POSTUL = \u0026#39;S\u0026#39; OR COD_SIT_POSTUL_ANT = \u0026#39;S\u0026#39; OR COD_SIT_POSTUL_INICIAL = \u0026#39;S\u0026#39;) GROUP BY ANO_ADMISION , CARRERA , PREFERENCIA ORDER BY ANO_ADMISION DESC , PREFERENCIA ASC Número de estudiantes matriculados según carreras de preferencia postulada por año-periodo de admisión #  SELECT ANO_ADMISION , CARRERA , PREFERENCIA , COUNT(1) AS NUM_POSTULANTES FROM ADMISION.TBL_VW_FT_ADMISION_PAS WHERE (COD_SIT_POSTUL = \u0026#39;U\u0026#39; OR COD_SIT_POSTUL_ANT = \u0026#39;U\u0026#39; OR COD_SIT_POSTUL_INICIAL = \u0026#39;U\u0026#39;) GROUP BY ANO_ADMISION , CARRERA , PREFERENCIA ORDER BY ANO_ADMISION DESC , PREFERENCIA ASC 8. Admisión en programas de magister y doctorado #  Número de estudiantes: postulantes, aceptados y rechazados en programas de magíster y doctorado por año-periodo de admisión #  SELECT ANO_ADMIS , SEXO , NOM_CASO_ADMIS , NOM_ESTADO_POSTULACION , COUNT(1) AS NUM_POSTULANTES FROM ADMISION.TBL_VW_FT_ADMISION_ESP_ORD_PAS WHERE COD_CASO_ADMIS IN (110, 150, 190, 111, 125, 112) AND COD_EST_POSTULACION NOT IN (6, 7, 8) GROUP BY ANO_ADMIS , SEXO , NOM_CASO_ADMIS , NOM_ESTADO_POSTULACION ORDER BY ANO_ADMIS DESC Número de matriculados en programas de magíster y doctorado por año-periodo de admisión #  SELECT ANO_ADMIS , SEXO , NOM_CASO_ADMIS , COUNT(1) AS NUM_POSTULANTES FROM ADMISION.TBL_VW_FT_ADMISION_ESP_ORD_PAS WHERE COD_CASO_ADMIS IN (110, 150, 190, 111, 125, 112) AND COD_EST_POSTULACION IN (6, 7, 8) GROUP BY ANO_ADMIS , SEXO , NOM_CASO_ADMIS ORDER BY ANO_ADMIS DESC "}),a.add({id:7,href:'/internados/banner/indicadores/',title:"Indicadores",section:"Banner",content:"Sesión de Convergencia: Indicadores Banner #  A continuación un análisis con los cruces para responder a los indicadores para BANNER.\n   ID Indicador Definición     1 Promedio Ponderado Acumulado (PPA) Promedio ponderado de los alumnos a lo largo de su carrera, según la cantidad de créditos de cada curso   2 Estudiantes según información de admisión Cantidad de estudiantes en un periodo académico, según la dependencia educacional del colegio del cual egresó   2 Estudiantes según información de admisión Cantidad de estudiantes en un periodo académico, según su región o comuna de procedencia   3 Estudiantes según situación académica Cantidad de estudiantes según la situación académica que presentan en cada periodo académico   4 Retiro de cursos Cantidad de estudiantes, por periodo académico, que retiran cursos   4 Retiro de cursos Cantidad de cursos retirados, por periodo académico   5 Estudiantes según nivel del programa Cantidad de estudiantes vigentes, en cada periodo académico, según el nivel del programa en el que están inscritos   6 Deserción por carrera Tasa de alumnos que desertan por cohorte, en cada periódo académico   7 Estudiantes con cursos inscritos según nivel del curso Cantidad de estudiantes con cursos inscritos, según el nivel del curso   8 Carga académica Cantidad de cursos inscritos por los estudiantes según el o los programas en los que está adscrito, en un determinado periodo académico   8 Carga académica Cantidad de créditos inscritos por los estudiantes según el o los programas en los que está adscrito, en un determinado periodo académico   9 Estudiantes en carreras paralelas Cantidad de estudiantes que estudian 2 o más programas en forma simultánea   10 Estudiantes sin atraso curricular Cantidad de estudiantes que han aprobado todos sus créditos inscritos   10 Estudiantes sin atraso curricular Cantidad de estudiantes, por cohorte, según grado de avance curricular   11 Tasa de aprobación o reprobación Tasa de estudiantes total que aprueban o reprueban los cursos inscritos, respecto del total de estudiantes por curso, en un periodo académico   11 Tasa de aprobación o reprobación Tasa de estudiantes de 1er año que aprueban o reprueban los cursos inscritos, respecto del total de estudiantes por curso, en un periodo académico   12 Duración real de la carrera Promedio de la suma de semestres que tardan los estudiantes, por cohorte, en completar sus programas   13 Estudiantes que egresan o se titulan oportunamente Cantidad de estudiantes que finalizan sus programas académicos en hasta 2 semestres más que la duración oficial de la carrera   13 Estudiantes que egresan o se titulan oportunamente Tasa de estudiantes que finalizan sus programas académicos en hasta 2 semestres más que la duración oficial de la carrera, respecto del total de la cohorte    DISCLAIMER\nPara responder a los indicadores se usan las vistas:\nSandobox-Datagov_Prod.SC.STUDENT_360_PAS Y\nSandobox-Datagov_Prod.SC.STUDENT_360_PPA_PPS_PAS   1. Promedio Ponderado Acumulado (PPA) #  Promedio ponderado de los alumnos a lo largo de su carrera, según la cantidad de créditos de cada curso #  SELECT rut , semestre , ppa FROM SC.STUDENT_360_PPA_PPS_PAS 2. Estudiantes según información de admisión #  Cantidad de estudiantes en un periodo académico, según la dependencia educacional del colegio del cual egresó #  SELECT periodo_academico , school_financing_type_name , COUNT(*) AS num_estudiantes FROM SC.STUDENT_360_PAS WHERE school_financing_type_name IS NOT NULL GROUP BY periodo_academico , school_financing_type_name ORDER BY periodo_academico DESC Cantidad de estudiantes en un periodo académico, según su región o comuna de procedencia #  SELECT periodo_academico , region , COUNT(*) AS num_estudiantes FROM SC.STUDENT_360_PAS WHERE region IS NOT NULL GROUP BY periodo_academico , region ORDER BY periodo_academico DESC 3. Estudiantes según situación académica #  Cantidad de estudiantes según la situación académica que presentan en cada periodo académico #  Tener en cuentar que el statement ORDER BY es \u0026ldquo;costoso\u0026rdquo; en términos de recursos, por lo que usarlo implica que la query va a tardar en devolver resultados.\nSELECT academic_status_validity_name -- nombre del estado: vigente, no vigente, vigente sin cursos  , periodo_academico , COUNT(*) AS num_estudiantes FROM SC.STUDENT_360_PAS GROUP BY academic_status_validity_name , periodo_academico ORDER BY periodo_academico DESC 4. Retiro de cursos #  Cantidad de estudiantes, por periodo académico, que retiran cursos #  SELECT registration_type_name , periodo_academico , count(*) AS num_estudiantes FROM SC.STUDENT_360_PAS WHERE registration_type_id IN (\u0026#39;DX\u0026#39;, \u0026#39;DD\u0026#39;, \u0026#39;DW\u0026#39;, \u0026#39;DS\u0026#39;) GROUP BY registration_type_name , periodo_academico ORDER BY periodo_academico DESC Cantidad de cursos retirados, por periodo académico #  Cantidad de cursos retirados por cada período académico de acuerdo al tipo de retiro:\nSELECT periodo_academico , registration_type_name , count(course_id) AS num_cursos_retirados FROM SC.STUDENT_360_PAS WHERE course_id IS NOT NULL AND registration_type_id IN (\u0026#39;DX\u0026#39;, \u0026#39;DD\u0026#39;, \u0026#39;DW\u0026#39;, \u0026#39;DS\u0026#39;) GROUP BY periodo_academico , registration_type_name ORDER BY periodo_academico DESC Cantidad de curso retirados por estudiante por cada período académico de acuerdo al tipo de retiro:\nSELECT rut , periodo_academico , registration_type_name , count(course_id) AS num_cursos_retirados FROM SC.STUDENT_360_PAS WHERE course_id IS NOT NULL AND registration_type_id IN (\u0026#39;DX\u0026#39;, \u0026#39;DD\u0026#39;, \u0026#39;DW\u0026#39;, \u0026#39;DS\u0026#39;) GROUP BY rut , periodo_academico , registration_type_name ORDER BY periodo_academico DESC 5. Estudiantes según nivel del programa #  Cantidad de estudiantes vigentes, en cada periodo académico, según el nivel del programa en el que están inscritos #  SELECT cohorte , academic_level_name , count(*) AS num_estudiantes_vigentes FROM SC.STUDENT_360_PAS WHERE academic_level_id IS NOT NULL AND academic_status_validity = \u0026#39;AS\u0026#39; GROUP BY cohorte , academic_level_name ORDER BY periodo_academico DESC 6. Deserción por carrera #  Tasa de alumnos que desertan por cohorte, en cada periódo académico #  Cantidad de alumnos desertados por período académico:\nSELECT cohorte , periodo_academico , count(*) AS num_estudiante_desertados FROM SC.STUDENT_360_PAS WHERE academic_status_desc IN (\u0026#39;RENUNCIADO\u0026#39;, \u0026#39;ABANDONA\u0026#39;, \u0026#39;NOVIGCOMPERMA\u0026#39;, \u0026#39;ELIMINADO\u0026#39;) AND periodo_academico \u0026gt; 201902 -- solo nos interesa el perido académico actual (2020) GROUP BY cohorte , periodo_academico ORDER BY periodo_academico, cohorte DESC 7. Estudiantes con cursos inscritos según nivel del curso #  Cantidad de estudiantes con cursos inscritos, según el nivel del curso #  SELECT periodo_academico , academic_level_name , COUNT(DISTINCT rut) AS num_estudiantes FROM SC.STUDENT_360_PAS WHERE academic_status_desc = \u0026#39;INPROGRESS\u0026#39; AND registration_type_id IN (\u0026#39;RW\u0026#39;, \u0026#39;RE\u0026#39;, \u0026#39;RQ\u0026#39;, \u0026#39;RS\u0026#39;) AND academic_level_name IS NOT NULL GROUP BY periodo_academico , academic_level_name ORDER BY periodo_academico DESC 8. Carga académica #  Cantidad de cursos inscritos por los estudiantes según el o los programas en los que está adscrito, en un determinado periodo académico #  SELECT periodo_academico , academic_program_name , COUNT(*) AS num_cursos FROM SC.STUDENT_360_PAS WHERE registration_type_id IN (\u0026#39;RW\u0026#39;, \u0026#39;RE\u0026#39;, \u0026#39;RQ\u0026#39;, \u0026#39;RS\u0026#39;) GROUP BY periodo_academico , academic_program_name ORDER BY periodo_academico DESC Cantidad de créditos inscritos por los estudiantes según el o los programas en los que está adscrito, en un determinado periodo académico #  SELECT periodo_academico , academic_program_name , SUM(credits) AS creditos_totales FROM SC.STUDENT_360_PAS WHERE registration_type_id IN (\u0026#39;RW\u0026#39;, \u0026#39;RE\u0026#39;, \u0026#39;RQ\u0026#39;, \u0026#39;RS\u0026#39;) GROUP BY periodo_academico , academic_program_name ORDER BY periodo_academico DESC 9. Estudiantes en carreras paralelas #  Cantidad de estudiantes que estudian 2 o más programas en forma simultánea #  Result set para quienes tienen tipo de admisión Carrera Paralela:\nSELECT periodo_academico , academic_level_name , COUNT(*) as num_estudiantes FROM SC.STUDENT_360_PAS WHERE admission_type_name = \u0026#39;Carrera Paralela\u0026#39; AND academic_status_validity = \u0026#39;AS\u0026#39; AND academic_level_name IS NOT NULL GROUP BY periodo_academico , academic_level_name ORDER BY periodo_academico DESC 10. Estudiantes sin atraso curricular #  Cantidad de estudiantes que han aprobado todos sus créditos inscritos #  SELECT periodo_academico , academic_level_name , COUNT(distinct enrollment_id) as num_estudiantes FROM SC.STUDENT_360_PAS WHERE registration_type_id IN (\u0026#39;RS\u0026#39;, \u0026#39;RQ\u0026#39;, \u0026#39;RE\u0026#39;, \u0026#39;RW\u0026#39;) AND CAST(course_grade AS FLOAT) \u0026gt;= 4 AND course_grade IS NOT NULL AND academic_level_name IS NOT NULL GROUP BY periodo_academico , academic_level_name ORDER BY periodo_academico DESC Cantidad de estudiantes, por cohorte, según grado de avance curricular #  11. Tasa de aprobación o reprobación #  Tasa de estudiantes total que aprueban o reprueban los cursos inscritos, respecto del total de estudiantes por curso, en un periodo académico #  Para calcular la tasa de aprobación/reprobación, agregué una columna que tiene el número de aprobados/reprobados.\nSELECT periodo_academico , academic_level_name , estado_curso , COUNT(distinct enrollment_id) as num_estudiantes FROM SC.STUDENT_360_PAS WHERE registration_type_id IN (\u0026#39;RS\u0026#39;, \u0026#39;RQ\u0026#39;, \u0026#39;RE\u0026#39;, \u0026#39;RW\u0026#39;) --cursos inscritos only  AND course_grade IS NOT NULL AND academic_level_name IS NOT NULL GROUP BY periodo_academico , academic_level_name , estado_curso ORDER BY periodo_academico DESC Tasa de estudiantes de 1er año que aprueban o reprueban los cursos inscritos, respecto del total de estudiantes por curso, en un periodo académico #  Para calcular la tasa de aprobación/reprobación, agregué una columna que tiene el número de aprobados/reprobados.\nSELECT periodo_academico , academic_level_name , estado_curso , COUNT(distinct enrollment_id) as num_estudiantes FROM SC.STUDENT_360_PAS WHERE registration_type_id IN (\u0026#39;RS\u0026#39;, \u0026#39;RQ\u0026#39;, \u0026#39;RE\u0026#39;, \u0026#39;RW\u0026#39;) --cursos inscritos only  AND LEFT(cohorte, 4) = CAST(year AS NVARCHAR) AND course_grade IS NOT NULL AND academic_level_name IS NOT NULL GROUP BY periodo_academico , academic_level_name , estado_curso ORDER BY periodo_academico DESC DISCLAIMER\nPara responder a los indicadores en 12 y 13 se necesita el dato de duración de la carrera que viene en la tabla NORMALIZADO_BANNER.ACADEMIC_PROGRAM. Sin embargo, el campo duration viene con NULLs.  12. Duración real de la carrera #  Promedio de la suma de semestres que tardan los estudiantes, por cohorte, en completar sus programas #  13. Estudiantes que egresan o se titulan oportunamente #  Cantidad de estudiantes que finalizan sus programas académicos en hasta 2 semestres más que la duración oficial de la carrera #  Tasa de estudiantes que finalizan sus programas académicos en hasta 2 semestres más que la duración oficial de la carrera, respecto del total de la cohorte #    "}),a.add({id:8,href:'/internados/difusion/indicadores/',title:"Indicadores",section:"Difusión",content:"Sesión de Convergencia: Indicadores Difusión #  A continuación un análisis con los cruces para responder a los indicadores para Difusión.\n   ID Indicador Definición     1 Participación en actividades del programa de difusión. Número de potenciales postulantes según grupo-dependencia del establecimiento de educación secundaria que participan en al menos una actividad del programa de Difusión.   1 Participación en actividades del programa de difusión. Número de potenciales postulantes alcanzados por cada actividad del programa de Disfusión.   2 Potenciales postulantes interesados en la UC que participan en actividades del programa de Difusión. Número de potenciales postulantes interesados en la UC que participan en actividades del Programa de Difusión.   3 Colegios que participan en el programa de difusión. Número de colegios que participan en el programa de Difusión.   4 Potenciales postulantes según carrera de preferencia declarada. Número de potenciales postulantes según carrera de preferencia declarada.   5 Estudiantes embajadores UC y embajadores por cada carrera. Número de estudiantes embajadores UC.   5 Estudiantes embajadores UC y embajadores por cada carrera. Número de estudiantes embajadores embajadores por cada carrera.   6 Actividades del programa de Difusión. Número de actividades del Programa de Difusión por tipo de organizador.   7 Potenciales postulantes alcanzados según curso. Número de potenciales postulantes que son alcanzados, según curso.   8 Orientadores y directores de los establecimientos Educacionales, que pertenecen a la Red de Apoyo de la Comunidad Educativa. Número de orientadores y directores de los establecimientos educacionales, que pertenecen a la Red de Apoyo de la Comunidad Educativa.   9 Potenciales postulantes en programa de Preparación y Exploración Vocacional. Número de potenciales postulantes en programa de Preparación y Exploración Vocacional.    DISCLAIMER\nPara responder a los indicadores se usa la vista:\nSandobox-Datagov_Prod.BDGI.DIFUSION   1. Participación en actividades del programa de difusión #  Número de potenciales postulantes según grupo-dependencia del establecimiento de educación secundaria que participan en al menos una actividad del programa de Difusión #  SELECT grupo_dependencia , COUNT(rut) AS num_potenciales_postul FROM BDGI.DIFUSION WHERE grupo_dependencia IS NOT NULL GROUP BY grupo_dependencia Número de potenciales postulantes alcanzados por cada actividad del programa de Disfusión #  No hay claridad sobre cómo responder este indicador, por lo que se requiere conversar con las personas encargadas de los orígenes.\n2. Potenciales postulantes interesados en la UC que participan en actividades del programa de Difusión #  Número de potenciales postulantes interesados en la UC que participan en actividades del Programa de Difusión #  SELECT COUNT(rut) AS num_potenciales_postul FROM BDGI.DIFUSION WHERE organizador_del_evento = \u0026#39;Difusión UC\u0026#39; 3. Colegios que participan en el programa de difusión #  Número de colegios que participan en el programa de Difusión #  Aquí incluimos la lógica (dentro de la vista) que nos dio SalesForce.\nSELECT COUNT(DISTINCT id_colegio) AS num_colegios FROM BDGI.DIFUSION -- WHERE organizador_del_evento = \u0026#39;Difusión UC\u0026#39; 4. Potenciales postulantes según carrera de preferencia declarada #  Número de potenciales postulantes según carrera de preferencia declarada #  SELECT carrera_de_interes , COUNT(DISTINCT rut) num_potenciales_postul FROM BDGI.DIFUSION GROUP BY carrera_de_interes ORDER BY num_potenciales_postul DESC 5. Estudiantes embajadores UC y embajadores por cada carrera #  No hay claridad sobre cómo obtener este indicador.\nNúmero de estudiantes embajadores UC #  Número de estudiantes embajadores embajadores por cada carrera #  6. Actividades del programa de Difusión #  No hay claridad sobre cómo obtener este indicador.\nNúmero de actividades del Programa de Difusión por tipo de organizador #  7. Potenciales postulantes alcanzados según curso #  Número de potenciales postulantes que son alcanzados, según curso #  SELECT curso , COUNT(DISTINCT rut) num_potenciales_postul FROM BDGI.DIFUSION WHERE curso IN (\u0026#39;7°\u0026#39;, \u0026#39;8°\u0026#39;, \u0026#39;I°\u0026#39;, \u0026#39;II°\u0026#39;, \u0026#39;III°\u0026#39;, \u0026#39;IV°\u0026#39;) GROUP BY curso 8. Orientadores y directores de los establecimientos Educacionales, que pertenecen a la Red de Apoyo de la Comunidad Educativa #  Número de orientadores y directores de los establecimientos educacionales, que pertenecen a la Red de Apoyo de la Comunidad Educativa #  SELECT COUNT(DISTINCT rut_rol) num_directores_y_orientadores FROM BDGI.DIFUSION WHERE nombre_cargo IN (\u0026#39;Director\u0026#39;, \u0026#39;Orientador\u0026#39;) 9. Potenciales postulantes en programa de Preparación y Exploración Vocacional #  No hay claridad sobre cómo obtener este indicador.\nNúmero de potenciales postulantes en programa de Preparación y Exploración Vocacional #  "}),a.add({id:9,href:'/etl/mallas/malla-adl/',title:"Malla ADL",section:"Mallas",content:"Definición general #  El proceso de datalake consiste en traer distintos documentos, tablas y archivos y depositarlos en un contenedor del datalake. En particular se depositan en el contenedor raw en la siguiente ruta:\nraw/nombre_origen/nombre_sistema/nombre_owner/nombre_tabla/año/mes/dia/nombre_tabla_año_mes_dia.csv Proceso de carga a datalake #  1. Verificar y cargar en MCP.MCP_CATALOGO #  Si la tabla exista, se debe verificar que la columna FLG_ADL mantenga el valor 1.\nSi la tabla no existe, se debe realizar una inserción a la tabla de catálogo de la siguiente forma:\nForma general\nINSERT INTO MCP.MCP_CATALOGO (ORIGEN_SISTEMA,NOMBRE_SISTEMA,NOMBRE_OWNER,NOMBRE_TABLA,DESC_TABLA) VALUES(\u0026#39;ORIGEN_1\u0026#39;,\u0026#39;SISTEMA_1\u0026#39;,\u0026#39;ESQUEMA_1\u0026#39;,\u0026#39;TABLA_1\u0026#39;,\u0026#39;Descripción de la tabla 1\u0026#39;); Ejemplo\nINSERT INTO MCP.MCP_CATALOGO (ORIGEN_SISTEMA,NOMBRE_SISTEMA,NOMBRE_OWNER,NOMBRE_TABLA,DESC_TABLA) VALUES(\u0026#39;ORACLE\u0026#39;,\u0026#39;UCLIBE\u0026#39;,\u0026#39;ADMISION\u0026#39;,\u0026#39;INSTITUCION_RESP\u0026#39;,\u0026#39;tabla que registra las instituciones...\u0026#39;); 2. Verificar/actualizar FLG #  Como se mencionó anteriormente en caso de que exista la tabla en el catalogo solo se debe actualizar flag.\nUpdate MCP.MCP_CATALOGO SET FLG_ADL = 1 WHERE NOMBRE_TABLA = \u0026#39;TABLA_1\u0026#39; AND NOMBRE_OWNER = \u0026#39;ESQUEMA_1\u0026#39; 3. Verificar en ETL si existe el origen-sistema-owner creado #  Para esto se debe checkear el datafactory dependiendo del ambiente en el que se requiere realizar la carga, adf-dev o adf-prod.\nUna vez dentro del datalake, se debe dirigir al pipeline:\nFASE 2 \u0026gt; Malla General \u0026gt; Malla ADL Dentro de este pipeline se debe chequear que exista el ORIGEN para el cual se va a realizar la carga.\n3.1 En caso de existir en origen se debe checkear un nivel anidado si existe el SISTEMA en el ETL #  Dentro del pipeline anterior se debe dirigir a:\nFASE 2 \u0026gt; Malla General \u0026gt; Malla ADL \u0026gt; ORIGEN Una vez dentro, se debe verificar si existe el sistema (pipeline con el nombre del sistema a cargar)\n3.1.1 En caso de existir el sistema #  Si existe el sistema queda por checkear solo si existe el owner para ese sistema\n3.1.2 En caso de no existir el sistema #  Se debe crear el pipeline correspondiente con el parametro del nuevo sistema.\n"}),a.add({id:10,href:'/etl/monitoreo/links-pbi/',title:"Reportes Power BI",section:"Monitoreo",content:"Definición general #  Versión beta de monitores de los procesos ETL.\nReportes monitoreo #  1. Monitoreo Catálogo y consistencia de tablas #   2. Monitoreo Proceso ETL #   3. Monitoreo Proceso DAC #   4. Internado de aceleración #   "}),a.add({id:11,href:'/sql/Modelo-DAC/Script_Ejemplo_uso/',title:"Script ejemplo de uso DAC",section:"DAC",content:"Discretionary access control (DAC)\n1. Crear politicas #  UPDATE DAC_SECURITY.DAC_USER_ENTITY_ACCESS SET flag_entity_access = 0 -- negar acceso a tabla UPDATE DAC_SECURITY.DAC_USER_ROW_LEVEL_SECURITY SET flag_rls_vigencia = 1 UPDATE DAC_SECURITY.DAC_USER_UNMASK SET flag_unmask = 1 UPDATE DAC_SECURITY.DAC_DATA_MASKING SET flag_dm_vigencia = 1 UPDATE DAC_SECURITY.DAC_DATA_CLASSIFICATION SET flag_dc_vigencia = 1/ 1. Borrar politicas #  UPDATE DAC_SECURITY.DAC_USER_ENTITY_ACCESS SET flag_entity_access = 1 -- dar acceso a tabla UPDATE DAC_SECURITY.DAC_USER_ROW_LEVEL_SECURITY SET flag_rls_vigencia = 0 UPDATE DAC_SECURITY.DAC_USER_UNMASK SET flag_unmask = 0 UPDATE DAC_SECURITY.DAC_DATA_MASKING SET flag_dm_vigencia = 0 UPDATE DAC_SECURITY.DAC_DATA_CLASSIFICATION SET flag_dc_vigencia = 0/ 3. Validar existencia de políticas #  SELECT * FROM sys.security_policies -- RLS SELECT * FROM sys.masked_columns -- Data Masking SELECT * FROM sys.sensitivity_classifications -- Data Classification SELECT * FROM DAC_SECURITY.DAC_USER_CHECK_SELECT_PERMISSIONS -- SELECT permissions "}),a.add({id:12,href:'/sql/procedures/',title:"SP",section:"SQL",content:"  "}),a.add({id:13,href:'/etl/mallas/malla-stg/',title:"Malla STG",section:"Mallas",content:"Asumiendo que se realizó anteriormente el proceso de malla ADL, la tabla a actualizar ya se encuentra cargada en el MCP.MCP_CATALOGO, Con esto se deben realizar dos cosas:\n### 1. Verificar/actualizar FlG Como se mencionó anteriormente en caso de que exista la tabla en el catalogo solo se debe actualizar flag.\nUpdate [MCP].[MCP_CATALOGO] SET FLG_STG = 1 WHERE NOMBRE_TABLA = \u0026#39;TABLA_1\u0026#39; and NOMBRE_OWNER = \u0026#39;ESQUEMA_1\u0026#39; ### 2. Actualizar fecha de proceso\n"}),a.add({id:14,href:'/etl/mallas/mallamdm/pruebamalla/',title:"Prueba malla",section:"Malla MDM",content:"Pruebas de la malla #  Para probar la malla existen dos entidades:\n MDIUC.PERSON_TEST MDIUC.COUNTRY  PERSON_TEST #  Corresponde a una versión reducida de PERSON. Sus tablas de origen son:\n NORMALIZADO_TEST.PERSON_BANNER NORMALIZADO_TEST.PERSON_PEOPLE_SOFT  Cada tabla contiene el RUT, dígito verificador, apellido paterno y materno, y el nombre. Los registros de estas tablas de extrajeron de Banner y PeopleSoft respectivamente.\nCada tabla contiene 90 registros.\nExisten 80 RUTs que aparecen en ambas tablas. De ellos:\n  Hay 5 personas con el mismo RUT pero distintos nombres entre PERSON_BANNER y PERSON_PEOPLE_SOFT (personas distintas). Para una de ellas, existe una resolución manual en las tablas CONFLICTIVE_PERSON_TEST y RESOLUTION_PERSON_TEST.\n  Hay 10 personas con el mismo RUT pero con el nombre un poco distinto entre PERSON_BANNER y PERSON_PEOPLE_SOFT (misma persona).\n  Hay 65 personas con mismo RUT y mismo nombre entre PERSON_BANNER y PERSON_PEOPLE_SOFT.\n  COUNTRY #  Esta entidad con fuente oficial hace referencia a las tablas:\n UC_BANNER.PAIS NORMALIZADO_PEOPLE_SOFT.COUNTRY  Cómo llenar las tablas que consume el pipeline MDM #  A continuación, los pasos para llenar la tablas que se utilizan por el pipeline del MDM.\nPasos para llenar las tablas que consume el pipeline del MDM #   Limpiar las tablas que utiliza el pipeline. Para ello ejecutamos el siguiente script:  TRUNCATE TABLE MCP_MDIUC.COMPARING_RULE TRUNCATE TABLE MCP_MDIUC.GROUPING_RULE TRUNCATE TABLE MCP_MDIUC.ENTITY_ATTRIBUTE_SYSTEM_MAPPING /* Due to some of their columns being referenced as FK by other tables, we cannot simply truncate these tables. So we delete their rows */ -- MCP_MDIUC.ENTITY_SYSTEM_TABLE DELETE FROM MCP_MDIUC.ENTITY_SYSTEM_TABLE WHERE entity_system_table_id IN (SELECT entity_system_table_id FROM MCP_MDIUC.ENTITY_SYSTEM_TABLE) -- MCP_MDIUC.ENTITY_ATTRIBUTE DELETE FROM MCP_MDIUC.ENTITY_ATTRIBUTE WHERE entity_attribute_id IN (SELECT entity_attribute_id FROM MCP_MDIUC.ENTITY_ATTRIBUTE) -- MCP_MDIUC.ENTITY DELETE FROM MCP_MDIUC.ENTITY WHERE entity_id IN (SELECT entity_id FROM MCP_MDIUC.ENTITY) Poblamos las tablas con datos:  -- ENTITY INSERT INTO MCP_MDIUC.ENTITY ([name], is_valid, has_official_source) VALUES (\u0026#39;PERSON_TEST\u0026#39;,1,0) , (\u0026#39;PERSON_TEST_2\u0026#39;,0,0) -- ENTITY_ATTRIBUTE INSERT INTO MCP_MDIUC.ENTITY_ATTRIBUTE (entity_id, attribute_name, attribute_type, is_primary_key) VALUES (20,\u0026#39;rut\u0026#39;,\u0026#39;nvarchar\u0026#39;,1) , (20,\u0026#39;dv\u0026#39;,\u0026#39;nvarchar\u0026#39;,0) , (20,\u0026#39;paternal_last_name\u0026#39;,\u0026#39;nvarchar\u0026#39;,0) , (20,\u0026#39;maternal_last_name\u0026#39;,\u0026#39;nvarchar\u0026#39;,0) , (20,\u0026#39;name\u0026#39;,\u0026#39;nvarchar\u0026#39;,0) , (21,\u0026#39;rut\u0026#39;,\u0026#39;nvarchar\u0026#39;,1) , (21,\u0026#39;dv\u0026#39;,\u0026#39;nvarchar\u0026#39;,0) , (21,\u0026#39;paternal_last_name\u0026#39;,\u0026#39;nvarchar\u0026#39;,0) , (21,\u0026#39;maternal_last_name\u0026#39;,\u0026#39;nvarchar\u0026#39;,0) , (21,\u0026#39;name\u0026#39;,\u0026#39;nvarchar\u0026#39;,0) -- ENTITY_SYSTEM_TABLE INSERT INTO MCP_MDIUC.ENTITY_SYSTEM_TABLE(entity_id, [schema_name], table_name, primary_key) VALUES (20,\u0026#39;NORMALIZADO_TEST\u0026#39;,\u0026#39;PERSON_BANNER\u0026#39;,\u0026#39;rut\u0026#39;) , (20,\u0026#39;NORMALIZADO_TEST\u0026#39;,\u0026#39;PERSON_PEOPLE_SOFT\u0026#39;,\u0026#39;rut\u0026#39;) , (21,\u0026#39;NORMALIZADO_TEST\u0026#39;,\u0026#39;PERSON_BANNER\u0026#39;,\u0026#39;rut\u0026#39;) , (21,\u0026#39;NORMALIZADO_TEST\u0026#39;,\u0026#39;PERSON_PEOPLE_SOFT\u0026#39;,\u0026#39;rut\u0026#39;) -- ENTITY_ATTRIBUTE_SYSTEM_MAPPING INSERT INTO MCP_MDIUC.ENTITY_ATTRIBUTE_SYSTEM_MAPPING (entity_attribute_id, entity_system_table_id, column_name, attribute_rank) VALUES (85,36,\u0026#39;rut\u0026#39;,1) , (85,37,\u0026#39;rut\u0026#39;,2) , (86,36,\u0026#39;check_digit\u0026#39;,1) , (86,37,\u0026#39;check_digit\u0026#39;,2) , (87,36,\u0026#39;paternal_last_name\u0026#39;,1) , (87,37,\u0026#39;paternal_last_name\u0026#39;,2) , (88,36,\u0026#39;maternal_last_name\u0026#39;,1) , (88,37,\u0026#39;maternal_last_name\u0026#39;,2) , (89,36,\u0026#39;first_name\u0026#39;,1) , (89,37,\u0026#39;name\u0026#39;,2) , (90,38,\u0026#39;rut\u0026#39;,1) , (90,39,\u0026#39;rut\u0026#39;,2) , (91,38,\u0026#39;check_digit\u0026#39;,1) , (91,39,\u0026#39;check_digit\u0026#39;,2) , (92,38,\u0026#39;paternal_last_name\u0026#39;,1) , (92,39,\u0026#39;paternal_last_name\u0026#39;,2) , (93,38,\u0026#39;maternal_last_name\u0026#39;,1) , (93,39,\u0026#39;maternal_last_name\u0026#39;,2) , (94,38,\u0026#39;first_name\u0026#39;,1) , (94,39,\u0026#39;name\u0026#39;,2) -- GROUPING_RULE INSERT INTO MCP_MDIUC.GROUPING_RULE VALUES (85) , (90) -- COMPARING_RULE INSERT INTO MCP_MDIUC.COMPARING_RULE (entity_attribute_id, rule_type, parameter, process) VALUES (87,\u0026#39;fuzzy_allow_empty\u0026#39;,70,\u0026#39;concat\u0026#39;) , (88,\u0026#39;fuzzy_allow_empty\u0026#39;,70,\u0026#39;concat\u0026#39;) , (89,\u0026#39;fuzzy_allow_empty\u0026#39;,70,\u0026#39;concat\u0026#39;) , (92,\u0026#39;fuzzy_allow_empty\u0026#39;,70,\u0026#39;concat\u0026#39;) , (93,\u0026#39;fuzzy_allow_empty\u0026#39;,70,\u0026#39;concat\u0026#39;) , (94,\u0026#39;fuzzy_allow_empty\u0026#39;,70,\u0026#39;concat\u0026#39;) El ejemplo anterior va a generar las siguientes tablas:\nMCP_MDIUC.ENTITY #     entity_id name is_valid has_official_source     20 PERSON_TEST 1 0   21 PERSON_TEST_2 0 0    MCP_MDIUC.ENTITY_ATTRIBUTE #     entity_attribute_id entity_id attribute_name attribute_type is_primary_key     85 20 rut nvarchar 1   86 20 dv nvarchar 0   87 20 paternal_last_name nvarchar 0   88 20 maternal_last_name nvarchar 0   89 20 name nvarchar 0   90 21 rut nvarchar 1   91 21 dv nvarchar 0   92 21 paternal_last_name nvarchar 0   93 21 maternal_last_name nvarchar 0   94 21 name nvarchar 0    MCP_MDIUC.ENTITY_SYSTEM_TABLE #     entity_system_table_id entity_id schema_name table_name primary_key     36 20 NORMALIZADO_TEST PERSON_BANNER rut   37 20 NORMALIZADO_TEST PERSON_PEOPLE_SOFT rut   38 21 NORMALIZADO_TEST PERSON_BANNER rut   39 21 NORMALIZADO_TEST PERSON_PEOPLE_SOFT rut    MCP_MDIUC.ENTITY_ATTRIBUTE_SYSTEM_MAPPING #     entity_attribute_system_mapping entity_attribute_id entity_system_table_id column_name attribute_rank     18 85 36 rut 1   19 85 37 rut 2   20 86 36 check_digit 1   21 86 37 check_digit 2   22 87 36 paternal_last_name 1   23 87 37 paternal_last_name 2   24 88 36 maternal_last_name 1   25 88 37 maternal_last_name 2   26 89 36 first_name 1   27 89 37 name 2   28 90 38 rut 1   29 90 39 rut 2   30 91 38 check_digit 1   31 91 39 check_digit 2   32 92 38 paternal_last_name 1   33 92 39 paternal_last_name 2   34 93 38 maternal_last_name 1   35 93 39 maternal_last_name 2   36 94 38 first_name 1   37 94 39 name 2    MCP_MDIUC.GROUPING_RULE #     grouping_rule_id entity_attribute_id     4 85   5 90    MCP_MDIUC.COMPARING_RULE #     comparing_id entity_attribute_id rule_type parameter process     4 87 fuzzy_allow_empty 70 concat   5 88 fuzzy_allow_empty 70 concat   6 89 fuzzy_allow_empty 70 concat   7 92 fuzzy_allow_empty 70 concat   8 93 fuzzy_allow_empty 70 concat   9 94 fuzzy_allow_empty 70 concat    "}),a.add({id:15,href:'/etl/mallas/mallamdm/revision/',title:"revision",section:"Malla MDM",content:"revision mdm #  /***\n1. USABILIDAD #   1.1 Configuración de pipeline con un grupo normalizado: se requieren (siete insert en cada prueba de configuración) =\u0026gt; mayor probabilidad de fuente error humano. 1.2 Te permite solo un grupo limitado de datos para ingresar (datetime,int,nvarchar,varchar) -\u0026gt;errores con float / bit 1.3  RESULTADOS #  2.1 RENDIMIENTO TABLA PAISES #  ----------PRUEBA 1------------------ TABLA GOLDEN 249--\u0026gt; TABLA DESTINO 145 --\u0026gt; queda con menos datos de los originales apesar de ser golden record, se descartan 104 145/249 =\u0026gt; 58 % ----------PRUEBA DE CRUCES CON SQL------------ 30 SEGS TABLA GOLDEN 249--\u0026gt; TABLA DESTINO 249 --\u0026gt; queda con menos datos de los originales apesar de ser golden record, se descartan 104 188/249 =\u0026gt; 75%  2.2 RENDIMIENTO TABLA PERSONA #  BANNER,PEOPLESOFT,PERS\n***/\nPASO A PRODUCCION GUIA #  1.eliminar todo del esquema normalizado_banner : a) tablas -\u0026gt; EXEC [NORMALIZADO_BANNER].[DROP_ALL_TABLES] ok b) sp -\u0026gt; consulta manual de SP\u0026rsquo;s c) utils -\u0026gt; consulta manual de SP\u0026rsquo;s d) eliminar-\u0026gt; funciones SQL_SCALAR_FUNCTION\n2.eliminar todo del esquema normalizado_peoplesoft : a) tablas -\u0026gt; procedure b) sp -\u0026gt; consulta manual de SP\u0026rsquo;s c) utils -\u0026gt; consulta manual de SP\u0026rsquo;s d) eliminar funciones-\u0026gt; SQL_SCALAR_FUNCTION\n3.eliminar todos los utils del esquema normalizado: (ESTE ES UN ESQUEMA EN COMUN) a) utils -\u0026gt; consulta manual de SP\u0026rsquo;s\n4.crear del esquema normalizado: a) utils -\u0026gt; de la carpeta del github utils : ETL_Datawarehouse\\UTILS\n5.crear del esquema normalizado_banner: a) utils -\u0026gt; de la carpeta del github : NORMALIZADO_BANNER\\UTILS b) tablas -\u0026gt; de la carpeta del github : NORMALIZADO_BANNER ABLES c) sp -\u0026gt; de la carpeta del github : NORMALIZADO_BANNER\\UTILS\n6.crear del esquema normalizado_people_soft: a) utils -\u0026gt; de la carpeta del github : NORMALIZADO_PEOPLE_SOFT\\UTILS ok b) tablas -\u0026gt; de la carpeta del github : NORMALIZADO_PEOPLE_SOFT ABLES ok c) sp -\u0026gt; de la carpeta del github : NORMALIZADO_PEOPLE_SOFT\\UTILS ok\n7.para verificar cantidad de datos en tablas : SELECT * FROM MCP.MCP_ESPACIO_OCUPADO_BD WHERE SchemaName = \u0026lsquo;NORMALIZADO_PEOPLE_SOFT\u0026rsquo;\n7.1 para verificar existencia de objetos (tablas, triggers,sp\u0026rsquo;s,fk,pk,funciones) SELECT * FROM sys.objects where schema_name(schema_id) = \u0026lsquo;NORMALIZADO_PEOPLE_SOFT\u0026rsquo; order by type_desc\n8.PASO FINAL PARA CARGAR CON DATOS a) obtener listado de tablas que consumen los modelos. para eso ejecutar script =\u0026gt; (FALTA ESTANDARIZAR ESE PROCESO) b) Actualizar fecha de proceso en tabla MCP.MCP_FECHA_PROCESO =\u0026gt; falta estandarizar esto c) ejecutar script utils. EXEC [NORMALIZADO_PEOPLE_SOFT].[UPDATE_MCP_DSP] EXEC [NORMALIZADO_BANNER].[UPDATE_MCP_DSP]\n***/\n"}),a.add({id:16,href:'/etl/monitoreo/',title:"Monitoreo",section:"ETL",content:""}),a.add({id:17,href:'/etl/mallas/malla-sp/',title:"Malla SP",section:"Mallas",content:"Proceso ETL para la transformación de tablas #  La malla SP corresponde a un conjunto de ejecuciones de los procedimientos almacenados que suceden en la base de datos STAGE. Este proceso es parte del flujo completo del ETL en el pipeline de \u0026ldquo;malla general\u0026rdquo; el cual es ejecutado diariamente.\nLa malla SP en el contexto del pipeline:\n"}),a.add({id:18,href:'/etl/mallas/malla-sbx/',title:"Malla SBX",section:"Mallas",content:"asdasd\n"}),a.add({id:19,href:'/etl/actualizacion-carga/actualizacion/',title:"Actualización de tablas",section:"Actualización y Carga",content:"Actualización de tablas cuando el OWNER existe en MCP_CATALOGO #  Para actualizar los datos de una tabla en particular en la BD Stage-Datagov_Prod, debemos aplicar los siguientes pasos:\nNota Queda pendiente poner este proceso en un proceso unificado, ya sea SP o cualquier otro artefacto.  Paso 1 #  Si, por ejemplo, queremos actualizar las tablas que consume una vista en la BD Sandbox-Datagov_Prod, corremos los siguiente:\nSELECT TABLE_SCHEMA , TABLE_NAME FROM INFORMATION_SCHEMA.VIEW_TABLE_USAGE WHERE VIEW_NAME = \u0026#39;\u0026lt;nombreVista\u0026gt;\u0026#39; Como se aprecia, solo recuperamos los campos que nos interesan, es decir, TABLE_SCHEMA y TABLE_NAME.\nPaso 2 #  Para asegurarnos que la tabla (o tablas) que queremos actualizar existen, hacemos la siguiente consulta en la BD Stage-Datagov_Prod:\nSELECT * FROM MCP.MCP_CATALOGO WHERE NOMBRE_OWNER = \u0026#39;\u0026lt;nombreOwner\u0026gt;\u0026#39; AND NOMBRE_TABLA = \u0026#39;\u0026lt;nombreTabla\u0026gt;\u0026#39; Haremos el update de la data de las tablas que existan en MCP.MCP_CATALOGO.\nPaso 3 #  Luego, vemos la última fecha de actualización de las tablas para corroborar la útlima fecha de actualización de las tablas. Para ello corremos el script en la BD Stage-Datagov_Prod:\nSELECT * FROM MCP.MCP_FECHA_PROCESO WHERE ID_CATALOGO IN ( SELECT ID_CATALOGO FROM MCP.MCP_CATALOGO WHERE NOMBRE_TABLA = \u0026#39;\u0026lt;nombreTabla\u0026gt;\u0026#39; AND NOMBRE_OWNER = \u0026#39;\u0026lt;nombreOwner\u0026gt;\u0026#39; ) Donde \u0026lt;nombreTabla\u0026gt; = TABLE_NAME y \u0026lt;nombreOwner\u0026gt; = TABLE_SCHEMA según la información recuperada en el Paso 0.\nPaso 4 #  Luego, seteamos la última y la próxima fecha de actulización de las tablas, tanto para la malla ADL como para la malla STG. Lo siguiente hará que se actualicen los datos en lsa tablas de la BD Stage-Datagov_Prod una vez que se ejecute el pipeline:\nUPDATE MCP.MCP_FECHA_PROCESO SET FCH_ULT_ACTUALIZACION_ADL = \u0026#39;1900-01-01\u0026#39; , FCH_PROX_ACTUALIZACION_ADL = (SELECT CAST(GETDATE() AS DATE)) -- Fecha del día en que hacemos la carga  , FCH_ULT_ACTUALIZACION_STG = \u0026#39;1900-01-01\u0026#39; , FCH_PROX_ACTUALIZACION_STG = (SELECT CAST(GETDATE() AS DATE)) -- Fecha del día en que hacemos la carga WHERE ID_CATALOGO IN ( SELECT ID_CATALOGO FROM MCP.MCP_CATALOGO WHERE NOMBRE_TABLA = \u0026#39;\u0026lt;nombreTabla\u0026gt;\u0026#39; AND NOMBRE_OWNER = \u0026#39;\u0026lt;nombreOwner\u0026gt;\u0026#39; ) Paso 5 #  Una vez configurada la fecha de actualización debemos ir al Azure Data Factory de producción y en la FASE 2 ejecutamos, primero, la malla ADL y luego la malla STG:\nPaso 6 #  Para asegurarnos que las tablas se modicaron en la fecha que hicimos el update corremos lo siguiente en la BD Stage-Datagov_Prod:\nSELECT [name] , create_date , modify_date , schema_id , SCHEMA_NAME(schema_id) FROM sys.objects WHERE SCHEMA_NAME(schema_id) = \u0026#39;\u0026lt;nombreOwner\u0026gt;\u0026#39; ORDER BY modify_date DESC Para ver el log del proceso corremos:\nSELECT TOP 50 * FROM [MCP].[MCP_LOG_PROCESO_BULK] ORDER BY ID_LOG_PROCESO DESC "}),a.add({id:20,href:'/internados/admision/',title:"Admisión",section:"INTERNADOS",content:""}),a.add({id:21,href:'/azure/',title:"AZURE",section:"Introduction",content:""}),a.add({id:22,href:'/internados/banner/',title:"Banner",section:"INTERNADOS",content:"  Indicadores   "}),a.add({id:23,href:'/etl/actualizacion-carga/cargatabla/',title:"Carga de tablas",section:"Actualización y Carga",content:"Carga de tablas desde Stage a Sandbox #  A continuación, se ilustra cómo cargar las tablas (cuando estas existen en el MCP_CATOLGO) ETNIA, INDICE_VULNER_ESCOLAR y POSTUL desde el esquema ADMISION de la BD Stage-Datagov_Prod hacia la BD Sandbox-Datagov_Prod. Ambas BDs viven en el server datagov-uc.\nPaso 1 #  Primero, vemos la última fecha de actualización de las tablas de interés para corroborar que no sea la del día en el que se hará la carga. Para ello corremos el script:\nSELECT * FROM MCP.MCP_FECHA_PROCESO WHERE ID_CATALOGO IN ( SELECT ID_CATALOGO FROM MCP.MCP_CATALOGO WHERE NOMBRE_TABLA IN (\u0026#39;ETNIA\u0026#39;, \u0026#39;INDICE_VULNER_ESCOLAR\u0026#39;, \u0026#39;POSTUL\u0026#39;) AND NOMBRE_OWNER = \u0026#39;ADMISION\u0026#39; ) Paso 2 #  Luego, seteamos la última y la próxima fecha de actulización de las tablas, tanto para la malla ADL como para la malla STG:\nUPDATE MCP.MCP_FECHA_PROCESO SET FCH_ULT_ACTUALIZACION_STG = \u0026#39;1900-01-01\u0026#39; , FCH_ULT_ACTUALIZACION_ADL = \u0026#39;1900-01-01\u0026#39; , FCH_PROX_ACTUALIZACION_STG = \u0026#39;2021-02-04\u0026#39; -- Fecha del día en que hacemos la carga  , FCH_PROX_ACTUALIZACION_ADL = \u0026#39;2021-02-04\u0026#39; -- Fecha del día en que hacemos la carga WHERE ID_CATALOGO IN ( SELECT ID_CATALOGO FROM MCP.MCP_CATALOGO WHERE NOMBRE_TABLA IN (\u0026#39;ETNIA\u0026#39;, \u0026#39;INDICE_VULNER_ESCOLAR\u0026#39;, \u0026#39;POSTUL\u0026#39;) AND NOMBRE_OWNER = \u0026#39;ADMISION\u0026#39; ) Paso 3 #  Antes de ir a DataFactory y ejecutar los pipelines, debemos asegurarnos que las tablas a cargar estén en la tabla SBX.CARGA_TABLA_STG_A_SBX. Para ellos corremos lo siguiente:\nSELECT * FROM SBX.CARGA_TABLA_STG_A_SBX WHERE NOMBRE_TABLA IN (\u0026#39;ETNIA\u0026#39;, \u0026#39;INDICE_VULNER_ESCOLAR\u0026#39;, \u0026#39;POSTUL\u0026#39;) AND NOMBRE_OWNER = \u0026#39;ADMISION\u0026#39; Es de esperar que la query no arroje resultados. Por lo que debemos agregar las tablas que se cargarán:\nINSERT INTO SBX.CARGA_TABLA_STG_A_SBX (NOMBRE_OWNER, NOMBRE_TABLA, FLG_SBX) VALUES (\u0026#39;ADMISION\u0026#39;, \u0026#39;ETNIA\u0026#39;, 1) , (\u0026#39;ADMISION\u0026#39;, \u0026#39;INDICE_VULNER_ESCOLAR\u0026#39;, 1) , (\u0026#39;ADMISION\u0026#39;, \u0026#39;POSTUL\u0026#39;, 1) Notemos que solo ingresamos los datos relevantes.\nPaso 4 #  Una vez ejecutados estos pasos, se ejecutan las mallas ADL, STG y SBX en el Azure Data Factory. La Ejecución debe ser secuencial:\nMalla ADL ➡️ Malla STG ➡️ Malla SBX\nFinalmente, y desde la BD Sandbox-Datagov_Prod, corremos lo siguiente para asegurarnos que las tablas se cargaron:\nSELECT [name] , create_date , modify_date , schema_id , SCHEMA_NAME(schema_id) FROM sys.objects WHERE SCHEMA_NAME(schema_id) = \u0026#39;ADMISION\u0026#39; AND CAST(create_date AS DATE) = \u0026#39;2021-02-04\u0026#39; "}),a.add({id:24,href:'/catalogo-uc/',title:"CATÁLOGO",section:"Introduction",content:"Catálogo UC #  Los catálogos de datos son herramientas esenciales para la administración, la conservación y el gobierno de datos (data governance). Se definen para un uso estratégico, muy útiles para la gestión de activos de datos y para mejorar la calidad y la productividad de los análisis. Así también facilitan la identificación, comprensión y colaboración entre datos y las reglas de negocio a nivel global.\nLos objetivos del catálogo concretamente son:\n Entregar y unificar información técnica, operacional y de negocio de los datos mediante una plataforma web. Permitir navegar de forma intuitiva el modelo MDI y su conexión con el DWI, y este último con los sistemas de origen para obtener una trazabilidad completa. Entregar información mediante la capa de servicios.  Producción #   Front-end: https://appcatalogouc-front.azurewebsites.net/ Back-end: https://appcatalogouc-back.azurewebsites.net/docs  Desarollo #   Front-end: https://appcatalogouc-front-dev.azurewebsites.net/ Back-end: https://appcatalogouc-back-dev.azurewebsites.net/docs  "}),a.add({id:25,href:'/utils/columndescription/',title:"Columns Description",section:"UTILS",content:"Descripción de la columna de una tabla #  SELECT SCHEMA_NAME(so.schema_id) as [schema_name] , so.name as table_name , sc.name as column_name , sep.value as column_description FROM sys.objects as so LEFT JOIN sys.columns as sc ON so.object_id = sc.object_id LEFT JOIN sys.extended_properties as sep ON so.object_id = sep.major_id AND sc.column_id =sep.minor_id WHERE so.name = \u0026lt;tableName\u0026gt; AND sc.name = \u0026lt;columnName\u0026gt; Importante\nSe creó la siguiente function para retornar la descripción de todas las tablas que coincidan con \u0026lt;tableName\u0026gt;:\nSELECT * FROM UTILS.ColumnDescription(N'\u0026lt;tableName\u0026gt;')\n "}),a.add({id:26,href:'/utils/columntypes/',title:"Columns Types",section:"UTILS",content:"Data type de las columnas de una tabla #  Para conocer los tipos, y el tamaño de una tabla particular, utilizamos la siguiente query:\nSELECT [Name] = c.[name] , [Type] = CASE WHEN tp.[name] IN (\u0026#39;varchar\u0026#39;, \u0026#39;char\u0026#39;, \u0026#39;varbinary\u0026#39;) THEN tp.[name] + \u0026#39;(\u0026#39; + IIF(c.max_length = -1, \u0026#39;max\u0026#39;, CAST(c.max_length AS VARCHAR(25))) + \u0026#39;)\u0026#39; WHEN tp.[name] IN (\u0026#39;nvarchar\u0026#39;,\u0026#39;nchar\u0026#39;) THEN tp.[name] + \u0026#39;(\u0026#39; + IIF(c.max_length = -1, \u0026#39;max\u0026#39;, CAST(c.max_length / 2 AS VARCHAR(25))) + \u0026#39;)\u0026#39; WHEN tp.[name] IN (\u0026#39;decimal\u0026#39;, \u0026#39;numeric\u0026#39;) THEN tp.[name] + \u0026#39;(\u0026#39; + CAST(c.[precision] AS VARCHAR(25)) + \u0026#39;, \u0026#39; + CAST(c.[scale] AS VARCHAR(25)) + \u0026#39;)\u0026#39; WHEN tp.[name] IN (\u0026#39;datetime2\u0026#39;) THEN tp.[name] + \u0026#39;(\u0026#39; + CAST(c.[scale] AS VARCHAR(25)) + \u0026#39;)\u0026#39; ELSE tp.[name] END , [RawType] = tp.[name] , [MaxLength] = c.max_length , [Precision] = c.[precision] , [Scale] = c.scale FROM sys.tables t JOIN sys.schemas s ON t.schema_id = s.schema_id JOIN sys.columns c ON t.object_id = c.object_id JOIN sys.types tp ON c.user_type_id = tp.user_type_id WHERE s.[name] = \u0026#39;\u0026lt;nombreEsquema\u0026gt;\u0026#39; AND t.[name] = \u0026#39;\u0026lt;nombreTabla\u0026gt;\u0026#39; Donde\n \u0026lt;nombreEsquema\u0026gt;: es el nombre del esquema \u0026lt;nombreTabla: es el nombre de la tabla  Importante\nSe creó el siguiente SP para conocer los column types:\nEXECUTE UTILS.ColumnTypes N'\u0026lt;nombreEsquema\u0026gt;', N'\u0026lt;nombreTabla\u0026gt;'\nY la function:\nSELECT * FROM UTILS.ColumnType (N'\u0026lt;nombreEsquema\u0026gt;', N'\u0026lt;nombreTabla\u0026gt;')\n "}),a.add({id:27,href:'/internados/difusion/',title:"Difusión",section:"INTERNADOS",content:""}),a.add({id:28,href:'/mdi/ficha-academica/docencia/',title:"Docencia y formación de personas",section:"Ficha Academica",content:"Tablas y cruces propuestos #  Cruce académicos y cursos dictados #  WITH CURSODICTADO AS ( SELECT HPHC.COD_PERS AS COD_PERS , HPHC.RUT AS RUT , ACA.NOMBRE_COMPLETO AS NOMBRE_COMPLETO , HC.COD_HIST_CURSO AS COD_HIST_CURSO , HC.ANO_CURSO AS ANO_CURSO , HC.SECCION AS SECCION_CURSO , HC.SIGLA AS SIGLA_CURSO , CU.NOM_CURSO AS NOMBRE_CURSO FROM UC_BANNER.R_HIST_PERS_HIST_CURSO AS HPHC JOIN UC_BANNER.HIST_CURSO AS HC ON HPHC.COD_HIST_CURSO = HC.COD_HIST_CURSO JOIN UC_BANNER.CURSO AS CU ON HC.SIGLA = CU.SIGLA JOIN web.Academicos_sipa AS ACA ON HPHC.RUT = ACA.RUT GROUP BY HPHC.COD_PERS , HPHC.RUT , ACA.NOMBRE_COMPLETO , HC.COD_HIST_CURSO , HC.ANO_CURSO , HC.SECCION , HC.SIGLA , CU.NOM_CURSO ) SELECT COUNT(DISTINCT COD_PERS) FROM CURSODICTADO -- este cruce entrega 2993 personas distintas  SELECT COUNT(DISTINCT COD_PERS) FROM web.Academicos_sipa -- esta vista indica que hay 3575 académicos Perfil de los datos generados:\n Años de los cursos desde 1991 - 2019 2993 académicos distintos 5048 cursos distintos Desde el 2016 en adelante, más de 3000 cursos por año  Cruce académicos y actividad académica #  WITH ACTIVACAD AS ( SELECT HPHC.COD_PERS AS COD_PERS , HPHC.RUT AS RUT , WAS.NOMBRE_COMPLETO AS NOMBRE_COMPLETO , HA.NOM_ACTIV_ACADEMICO AS NOMBRE_ACTIVIDAD_ACADEMICA , HA.COD_TIPO_ACTIV_ACADEMICO AS COD_TIPO_ACTIV_ACADEMICA , HATA.NOM_TIPO_ACTIV_ACADEMICO AS NOMBRE_TIPO_ACTIV_ACADEMICA -- , HATA.INTERNO_UC  , HATA.VIG_TIPO_ACTIV_ACADEMICO AS ACTIV_ACADEMICA_VIGENTE , CAST(HA.FECHA_INICIO AS DATE) AS FECHA_INICIO_ACTIV , CAST(HA.FECHA_FIN AS DATE) AS FECHA_FIN_ACTIV , HA.DESCRIP_ABREV_ACTIV AS DESCRIP_ABREV_ACTIV FROM HISTACADEMICO.ACTIV_ACADEMICO AS HA JOIN UC_BANNER.R_HIST_PERS_HIST_CURSO AS HPHC ON HA.COD_PERS = HPHC.COD_PERS JOIN web.Academicos_sipa AS WAS ON HPHC.RUT = HAU.RUT JOIN HISTACADEMICO.TIPO_ACTIV_ACADEMICO AS HATA ON HA.COD_TIPO_ACTIV_ACADEMICO = HATA.COD_TIPO_ACTIV_ACADEMICO GROUP BY HPHC.COD_PERS , HPHC.RUT , WAS.NOMBRE_COMPLETO , HA.NOM_ACTIV_ACADEMICO , HA.COD_TIPO_ACTIV_ACADEMICO , HATA.NOM_TIPO_ACTIV_ACADEMICO -- , HATA.INTERNO_UC  , HATA.VIG_TIPO_ACTIV_ACADEMICO , CAST(HA.FECHA_INICIO AS DATE) , CAST(HA.FECHA_FIN AS DATE) , HA.DESCRIP_ABREV_ACTIV ) SELECT * FROM ACTIVACAD --1061 Perfil de los datos generados:\n 1061 académicos distintos  "}),a.add({id:29,href:'/etl/',title:"ETL",section:"Introduction",content:"El proceso de ETL como su nombre lo dice, permite extraer transformar y cargar información desde multiples origenes y hacer uso de ellos.\n"}),a.add({id:30,href:'/internados/',title:"INTERNADOS",section:"Introduction",content:""}),a.add({id:31,href:'/utils/mapeofk/',title:"Mapeo de FK",section:"UTILS",content:"Mapero de FK #  Usamos el siguiente system util para ver la información relativa a la tabla. Al final aparecen las FK:\nUSE \u0026lt;dataBaseName\u0026gt;; GO EXEC sp_help N\u0026#39;\u0026lt;dataBaseName.schemaName.tableName\u0026gt;\u0026#39;; "}),a.add({id:32,href:'/sql/queries/',title:"Queries",section:"SQL",content:""}),a.add({id:33,href:'/utils/resultjson/',title:"Resultado de query en JSON",section:"UTILS",content:"Queries que muestran el resultado en JSON #   Resultado con top-level element:  SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = \u0026#39;\u0026lt;tableName\u0026gt;\u0026#39; FOR JSON PATH, ROOT(\u0026#39;\u0026lt;topLevelElementeName\u0026gt;\u0026#39;) Resultado sin top-level element:  SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = \u0026#39;\u0026lt;tableName\u0026gt;\u0026#39; FOR JSON PATH Resultado que entrega la misma estructura que la del SELECT statement:  SELECT TABLE_SCHEMA , TABLE_NAME , COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = \u0026#39;\u0026lt;tableName\u0026gt;\u0026#39; FOR JSON AUTO "}),a.add({id:34,href:'/utils/rowcount/',title:"Row count",section:"UTILS",content:"Row count de las tablas de un esquema en particular #  Para generar una tabla con el número de registros por tabla según esquema, ejecutamos la siguiente query:\nWITH [RowCount] AS ( SELECT SCHEMA_NAME(t.schema_id) AS [schema_name] , t.name AS table_name , s.row_count FROM sys.tables t JOIN sys.dm_db_partition_stats s ON t.object_id = s.object_id AND t.type = \u0026#39;U\u0026#39; AND t.name NOT LIKE \u0026#39;%dss%\u0026#39; AND s.index_id IN (0, 1) ) SELECT * FROM [RowCount] WHERE [schema_name] = \u0026#39;\u0026lt;nombreEsquema\u0026gt;\u0026#39; AND row_count \u0026lt;\u0026gt; 0 ORDER BY [schema_name], row_count DESC "}),a.add({id:35,href:'/sql/',title:"SQL",section:"Introduction",content:""}),a.add({id:36,href:'/utils/viewtableusage/',title:"Tablas consumidas por una vista",section:"UTILS",content:"Tablas que consume una vista #  Se creó la siguiente función en la BD Sandbox-Datagov_Prod para retornar las tablas que consume una vista con la fecha de modificación de cada tabla:\nSELECT * FROM UTILS.ViewTablesUsage() "})})()